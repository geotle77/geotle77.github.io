<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>分布式训练</title>
    <link href="/2025/10/03/distributed-training/"/>
    <url>/2025/10/03/distributed-training/</url>
    
    <content type="html"><![CDATA[<h1>分布式训练</h1><p>开始之前首先贴几个链接：</p><ul><li><a href="https://openmlsys.github.io/chapter_preface/index.html">openmlsys</a></li><li><a href="https://blog.csdn.net/weixin_44966641/article/details/131756853">分布式训练——通信原语</a></li><li><a href="https://zhuanlan.zhihu.com/p/569156416?ssr_src=heifetz">分布式——集合通信</a></li></ul><h2 id="背景">背景</h2><h3 id="算力不足">算力不足</h3><p>单处理器的算力不足是促使人们设计分布式训练系统的一个主要原因。一个处理器的算力可以用每秒钟浮点数操作（Floating Point Operations Per Second，FLOPS）来衡量。根据摩尔定律（Moore’s Law），中央处理器的算力每18个月增长2倍,并且中央处理器的算力目前正处在瓶颈期，这一定律也面临着失效的风险。虽然计算加速卡(如GPU和TPU)针对机器学习计算提供了大量的算力，但机器学习模型正在快速发展，模型对于算力需求每18个月增长了5、6倍。 <strong>解决处理器性能和算力需求之间鸿沟的关键就在于利用分布式计算</strong>。通过大型数据中心和云计算设施，可以快速获取大量的处理器。通过分布式训练系统有效管理这些处理器，可以实现算力的快速增长，从而持续满足模型的需求。</p><h3 id="内存不足">内存不足</h3><p>另外，训练机器学习模型需要使用到大量内存。训练机器学习模型需要大量内存。</p><pre><code class="hljs">举个例子：假设一个大型神经网络模型具有1000亿的参数，每个参数都由一个32位浮点数（4个字节）表达，存储模型参数就需要400GB的内存。在实际中，我们需要更多内存来存储激活值和梯度。假设激活值和梯度也用32位浮点数表达，那么其各自至少需要400GB内存，总的内存需求就会超过1200GB（即1.2TB）。而如今的硬件加速卡（如NVIDIA A100）仅能提供最高80GB的内存。</code></pre><p>单卡内存空间的增长受到硬件规格、散热和成本等诸多因素的影响，难以进一步快速增长。因此，我们需要分布式训练系统来同时使用数百个训练加速卡，从而为千亿级别的模型提供所需的TB级别的内存。</p><h2 id="系统架构">系统架构</h2><p>分布式训练的载体一般是大量用于分布式训练的服务器，并且依靠数据中心来进行管理。<strong>一个数据中心管理数百个集群，每个集群存在几百或者上千个服务器。</strong><br>为了确保分布式训练系统的高效运行，需要首先估计系统计算任务的计算和内存用量。</p><p>一个模型训练任务（Model Training Job）往往会有一组数据（如训练样本）或者任务（如算子）作为输入，利用一个计算节点（如GPU）生成一组输出（如梯度）。</p><p>分布式执行一般具有三个步骤：</p><ul><li>第一步将输入进行切分；</li><li>第二步将每个输入部分会分发给不同的计算节点，实现并行计算；</li><li>第三步将每个计算节点的输出进行合并，最终得到和单节点等价的计算结果。</li></ul><p>这种首先切分，然后并行，最后合并的模式，本质上实现了分而治之（Divide-and-Conquer）的方法：<strong>由于每个计算节点只需要负责更小的子任务，因此其可以更快速地完成计算，最终实现对整个计算过程的加速。</strong></p><h2 id="实现方法">实现方法</h2><p>分布式训练系统的设计目标是：<strong>将单节点训练系统转换成等价的并行训练系统，从而在不影响模型精度的条件下完成训练过程的加速。</strong>。<br><img src="/img/pics/distributed_training/singal_node.png" alt="single_node"><br>一个单节点训练系统往往如图所示。一个训练过程会由多个数据小批次（mini-batch）完成。训练系统会利用数据小批次生成梯度，提升模型精度。这个过程由一个训练程序实现。在实际中，这个程序往往实现了一个多层神经网络的执行过程。该神经网络的执行由一个<a href="../MLSYS/computational%20graph.md">计算图（Computational Graph）</a>表示。这个图有多个相互连接的算子（Operator），每个算子会拥有计算参数。每个算子往往会实现一个神经网络层（Neural Network Layer），而参数则代表了这个层在训练中所更新的的权重（Weights）。</p><p>在上篇文章中已经知道，为了更新参数，计算图的执行分为前向计算和反向计算两个阶段。前向计算的第一步会将数据读入第一个算子，该算子会根据当前的参数，计算出计算给下一个算子的数据。算子依次重复这个前向计算的过程（执行顺序：算子1，算子2，算子3），直到最后一个算子结束。最后的算子随之马上开始反向计算。反向计算中，每个算子依次计算出梯度（执行顺序：梯度3，梯度2，梯度1），并利用梯度更新本地的参数。反向计算最终在第一个算子结束。反向计算的结束也标志本次数据小批次的结束，系统随之读取下一个数据小批次，继续更新模型。</p><p>给定一个模型训练任务，人们会对数据和程序切分（Partition），从而完成并行加速。 单节点训练系统可以被归类于单程序单数据模式。</p><p>而假如用户希望使用更多的设备实现并行计算，</p><ul><li>一种方式是单程序多数据模式，也就是数据并行（data parallelism），<strong>首先可以选择对数据进行分区，并将同一个程序复制到多个设备上并行执行</strong>。</li><li>另一种并行方式是对程序进行分区（模型中的算子会被分发给多个设备分别完成）。这种模式是多程序单数据模式，常被称为模型并行（Model Parallelism）。</li><li>当训练超大型智能模型时，开发人员往往要同时对数据和程序进行切分，从而实现最高程度的并行。这种模式是多程序多数据模式，常被称为混合并行（Hybrid Parallelism）。</li></ul><h3 id="数据并行">数据并行</h3><p>数据并行是最常见的并行形式。在数据并行训练中，数据集被分割成几个碎片，每个碎片被分配到一个设备上。这相当于沿批次（Batch）维度对训练过程进行并行化。每个设备将持有一个完整的模型副本，并在分配的数据集碎片上进行训练。在反向传播之后，模型的梯度将会聚合（All Reduce），以便在不同设备上的模型参数能够保持同步。典型的数据并行实现：TensorFlow DistributedStrategy、PyTorch Distributed、Horovod DistributedOptimizer。</p><p>假定用户给定一个训练批次大小为$N$,并且希望使用$M$个并行设备来加速训练。那么，该训练批次大小会被分为$M$个分区，每个设别会分配到$\frac{N}{M}$个训练样本。这些设备共享一个训练程序的副本，在不同数据分区上独立执行、计算梯度。不同的设备（假设设备编号为$i$）会根据本地的训练样本计算出梯度$G_i$。最后为了确保程序参数的一致性，本地梯度$G_i$需要进行聚合，并计算出平均梯度（$\sum_{i=1}^N{G_i}/N$）。<br><img src="/img/pics/distributed_training/data_parallelism.png" alt="data parallelism"></p><p><strong>TIPS</strong>: 细节上，会有一个设备作为参数服务器来对每个训练设备中的梯度来进行累加，最后再广播到其他节点上。也可以将参数服务器分布在所有的节点上，每个训练设备只更新一部分梯度。</p><p>以下以pytorch中数据并行方法举例子。</p><h4 id="数据并行-torch-nn-DataParallel">数据并行(torch.nn.DataParallel)</h4><p>这是Pytorch最早提供的一种数据并行方式，它基于<strong>单进程多线程</strong>进行实现的，它使用一个进程来计算模型权重，在每个批处理期间将数据分发到每个GPU。</p><p>DataParallel 的计算过程如下所示：</p><ul><li>将 inputs 从主 GPU 分发到所有 GPU 上。</li><li>将 model 从主 GPU 分发到所有 GPU 上。</li><li>每个 GPU 分别独立进行前向传播，得到 outputs。</li><li>将每个 GPU 的 outputs 发回主 GPU。</li><li>在主 GPU 上，通过 loss function 计算出 loss，对 loss function 求导，求出损失梯度。</li><li>计算得到的梯度分发到所有 GPU 上。</li><li>反向传播计算参数梯度。</li><li>将所有梯度回传到主 GPU，通过梯度更新模型权重。<br>不断重复上面的过程。<br>但是它的缺点也很明显：</li></ul><p>单进程多线程带来的问题：DataParallel使用单进程多线程进行实现的，方便了信息的交换，但受困于 GIL，会带来性能开销，速度很慢。而且，只能在单台服务器（单机多卡）上使用（不支持分布式）。</p><pre><code class="hljs">The Python Global Interpreter Lock or GIL, in simple words, is a mutex (or a lock) that allows only one thread to hold the control of the Python interpreter.</code></pre><p>效率问题，主卡性能和通信开销容易成为瓶颈，GPU 利用率通常很低：数据集需要先拷贝到主进程，然后再分片（split）到每个设备上；权重参数只在主卡上更新，需要每次迭代前向所有设备做一次同步；每次迭代的网络输出需要聚集到主卡上。因此，通信很快成为一个瓶颈。除此之外，这将导致主卡和其他卡之间，GPU利用率严重不均。</p><h4 id="分布式数据并行（PyTorch-DDP）">分布式数据并行（PyTorch DDP）</h4><p>分布式数据并行(torch.nn.DistributedDataParallel)，是基于多进程进行实现的，每个进程都有独立的优化器，执行自己的更新过程。每个进程都执行相同的任务，并且每个进程都与所有其他进程通信。进程之间只传递梯度，因此网络通信就不再是瓶颈。<br><img src="/img/pics/distributed_training/DDP_parallelism.png" alt="分布式数据并行"></p><p>具体流程为：</p><ul><li>首先将 rank=0 进程中的模型参数广播到进程组中的其他进程；</li><li>然后，每个 DDP 进程都会创建一个 local Reducer 来负责梯度同步。</li><li>在训练过程中，每个进程从磁盘加载 batch 数据，并将它们传递到其 GPU。每个 GPU 都有自己的前向过程，完成前向传播后，梯度在各个 GPUs 间- 进行 All-Reduce，每个 GPU 都收到其他 GPU 的梯度，从而可以独自进行反向传播和参数更新。</li><li>同时，每一层的梯度不依赖于前一层，所以梯度的 All-Reduce 和后向过程同时计算，以进一步缓解网络瓶颈。</li><li>在后向过程的最后，每个节点都得到了平均梯度，这样各个 GPU 中的模型参数保持同步 。</li></ul><p>DistributedDataParallel方式可以更好地进行多机多卡运算，更好的进行负载均衡，运行效率也更高，虽然使用起来较为麻烦，但对于追求性能来讲是一个更好的选择。</p><h4 id="完全分片数据并行-Pytorch-FSDP">完全分片数据并行(Pytorch FSDP)</h4><p>通常来说，在模型训练的过程中，GPU上需要进行存储的参数包括了模型本身的参数、优化器状态、激活函数的输出值、梯度以及一些临时的Buffer。<br><img src="/img/pics/distributed_training/fan_image.png" alt="分布图"><br>可以看到模型参数仅占模型训练过程中所有数据的一部分，当进行混合精度运算时，其中模型状态参数（优化器状态 + 梯度+ 模型参数）占到了一大半以上。</p><p>针对模型状态的存储优化（去除冗余），DeepSpeed 提出了 ZeRO，ZeRO 使用的方法是分片，即每张卡只存 1/N 的模型状态量，这样系统内只维护一份模型状态参数。</p><p>ZeRO对 模型状态（Model States）参数进行不同程度的分割，主要有三个不同级别：</p><ol><li>ZeRO-1 : 优化器状态分片（ Optimizer States Sharding）</li><li>ZeRO-2 : 优化器状态与梯度分片（Optimizer States &amp; Gradients Sharding）</li><li>ZeRO-3 : 优化器状态、梯度和模型权重参数分片（Optimizer States &amp; Gradients &amp; Parameters Sharding）</li></ol><p>完全分片数据并行(torch.distributed.fsdp.FullyShardedDataParallel)，是Pytorch最新的数据并行方案。Pytorch DDP用起来简单方便，但是要求整个模型加载到一个GPU上，这使得大模型的训练需要使用额外复杂的设置进行模型分片。为了打破模型分片的障碍（包括模型参数，梯度，优化器状态），同时仍然保持数据并行的简单性，FSDP因此被提出。</p><p>FSDP是一种新型数据并行训练方法，但与传统的数据并行不同，传统的数据并行维护模型参数、梯度和优化器状态的每个 GPU 副本，而 FSDP 将所有这些状态跨数据并行工作线程进行分片，并且可以选择将模型参数分片卸载到 CPU。<br><img src="/img/pics/distributed_training/FSDP.png" alt="FSDP工作流程"></p><ul><li><strong>Model shard</strong>：每个GPU上仅存在模型的分片。</li><li><strong>All-gather</strong>：每个GPU通过all-gather从其他GPU收集所有权重，以在本地计算前向传播。</li><li><strong>Forward（local）</strong>：在本地进行前向操作。前向计算和后向计算都是利用完整模型。</li><li><strong>All-gather</strong>：然后在后向传播之前再次执行此权重收集。</li><li><strong>Backward（local）</strong>：本地进行后向操作。前向计算和后向计算都是利用完整模型，此时每个GPU上也都是全部梯度。</li><li><strong>Reduce-Scatter</strong>：在向后传播之后，局部梯度被聚合并且通过 Reduce-Scatter 在各个GPU上分片，每个分片上的梯度是聚合之后本分片对应的那部分。</li><li><strong>Update Weight（local）</strong>：每个GPU更新其局部权重分片。</li></ul><p>通常，模型层以嵌套方式用 FSDP 包装，因此，<strong>只有单个 FSDP 实例中的层需要在前向或后向计算期间将完整参数收集到单个设备</strong>。 计算完成后，收集到的完整参数将立即释放，释放的内存可用于下一层的计算。 当实例在计算中不活动时，FSDP 可以将参数、梯度和优化器状态卸载到 CPU。</p><p>解释ZeRO/FSDP的关键是我们可以把DDP之中的All-Reduce操作分解为独立的 Reduce-Scatter 和 All-Gather 操作。<br><img src="/img/pics/distributed_training/all_reduce.png" alt="all_reduece"></p><p>All-Reduce 是 Reduce-Scatter 和 All-Gather 的组合。标准 All-Reduce 操作可以分解为两个单独的阶段。</p><ul><li>Reduce-Scatter 阶段，在每个GPU上，会基于 rank 索引对 rank 之间相等的块进行求和。</li><li>All-Gather 阶段，每个GPU上的聚合梯度分片可供所有GPU使用。</li></ul><p>通过重新整理 Reduce-Scatter 和 All-Gather，每个 DDP worker只需要存储一个参数分片和优化器状态。</p><h3 id="模型并行">模型并行</h3><p>模型并行分为张量并行和流水线并行，张量并行为层内并行，对模型 Transformer 层内进行分割；流水线并行为层间并行，对模型不同的 Transformer 层间进行分割。<br><img src="/img/pics/distributed_training/tensor_and_pipeline.png" alt="两种方式"></p><p>模型并行往往用于解决单节点内存不足的问题。一个常见的内存不足场景是模型中含有大型算子，例如深度神经网络中需要计算大量分类的全连接层。完成这种大型算子计算所需的内存可能超过单设备的内存容量。那么需要对这个大型算子进行切分。</p><p>假设这个算子具有$P$个参数，而系统拥有$N$个设备，那么可以将$P$个参数平均分配给$N$个设备（每个设备分配$P/N$个参数），从而让每个设备负责更少的计算量，能够在内存容量的限制下完成前向计算和反向计算。这也就是层内并行的方式，也叫算子内并行/流水线并行。</p><p><img src="/img/pics/distributed_training/model_parallelism.png" alt="算子内并行"></p><p>假设一个神经网络具有两个算子，算子1的计算（包含正向和反向计算）需要预留16GB的内存，算子2的计算需要预留1GB的内存。而本例中的设备最多可以提供10GB的内存。为了完成这个神经网络的训练，需要对算子1实现并行。具体做法是，将算子1的参数平均分区，设备1和设备2各负责其中部分算子1的参数。由于设备1和设备2的参数不同，因此它们各自负责程序分区1和程序分区2。在训练这个神经网络的过程中，训练数据（按照一个小批次的数量）会首先传给算子1。由于算子1的参数分别由两个设备负责，因此数据会被广播（Broadcast）给这两个设备。不同设备根据本地的参数分区完成前向计算，生成的本地计算结果需要进一步合并，发送给下游的算子2。在反向计算中，算子2的数据会被广播给设备1和设备2，这些设备根据本地的算子1分区各自完成局部的反向计算。计算结果进一步合并计算回数据，最终完成反向计算。</p><p>另一种内存不足的场景是：模型的总内存需求超过了单设备的内存容量。在这种场景下，假设总共有$N$个算子和$M$个设备，可以将算子平摊给这$M$个设备，让每个设备仅需负责$N/M$个算子的前向和反向计算，降低设备的内存开销。这也就是层间并行，也称为张量并行/算子间并行。</p><p><img src="/img/pics/distributed_training/pipeline.png" alt="算子间并行"></p><h4 id="流水线并行">流水线并行</h4><p>所谓流水线并行，就是将模型的不同层放置到不同的计算设备，降低单个计算设备的显存消耗，从而实现超大规模模型训练。</p><p>如图所示，模型共包含四个模型层（如：Transformer层），被切分为三个部分，分别放置到三个不同的计算设备。即第 1 层放置到设备 0，第 2 层和第三 3 层放置到设备 1，第 4 层放置到设备 2。<br><img src="/img/pics/distributed_training/pipeline2.png" alt="流水线并行"></p><p>具体地讲，前向计算过程中，输入数据首先在设备 0 上通过第 1 层的计算得到中间结果，并将中间结果传输到设备 1，然后在设备 1 上计算得到第 2 层和第 3 层的输出，并将模型第 3 层的输出结果传输到设备 2，在设备 2 上经由最后一层的计算得到前向计算结果。反向传播过程类似。最后，各个设备上的网络层会使用反向传播过程计算得到的梯度更新参数。由于各个设备间传输的仅是相邻设备间的输出张量，而不是梯度信息，因此通信量较小。</p><p>根据流水线的设计不同，又可以进一步分为朴素流水线并行和微批次流水线并行等。</p><h5 id="朴素流水线">朴素流水线</h5><p>朴素流水线并行是实现流水线并行训练的最直接的方法。我们将模型按照层间切分成多个部分（Stage），并将每个部分（Stage）分配给一个 GPU。然后，我们对小批量数据进行常规的训练，在模型切分成多个部分的边界处进行通信。</p><p><img src="/img/pics/distributed_training/naive_pipeline.png" alt="朴素流水线并行"><br>朴素流水线存在最大的问题就是其会产生特别多的空泡，主要是因为该方案在任意给定时刻，除了一个 GPU 之外的其他所有 GPU 都是空闲的。因此，如果使用 4 个 GPU，则几乎等同于将单个 GPU 的内存量增加四倍，而其他资源 (如计算) 相当于没用上。朴素的流水线并行将会导致GPU使用率过低。</p><h5 id="微批次流水线">微批次流水线</h5><p>微批次（MicroBatch）流水线并行与朴素流水线几乎相同，但它通过将传入的小批次（minibatch）分块为微批次（microbatch），并人为创建流水线来解决 GPU 空闲问题，从而允许不同的 GPU 同时参与计算过程，可以显著提升流水线并行设备利用率，减小设备空闲状态的时间。<br><img src="/img/pics/distributed_training/micro_pipeline.png" alt="微批次流水线"></p><p>Gpipe就是谷歌以其为基础提出的一种流水线并行方案，可以通过纵向对模型进行切分解决了单个设备无法训练大模型的问题；同时，又通过微批量流水线增加了多设备上的并行程度，除此之外，还使用re-materialization（重计算）降低了单设备上的显存峰值</p><h4 id="流水线并行策略">流水线并行策略</h4><p>流水线并行根据执行的策略，又可以分为两种模式：F-then-B和1F1B模式。</p><h5 id="F-then-B-策略">F-then-B 策略</h5><p>F-then-B模式，即先进行前向计算，再进行反向计算。但由于其缓存了多个micro-batch的中间变量和梯度，显存的实际利用率并不高。<br><img src="/img/pics/distributed_training/F-then-B.png" alt="F-then-B策略"></p><h5 id="1F1B策略">1F1B策略</h5><p>1F1B（One Forward pass followed by One Backward pass）模式，是一种前向计算和反向计算交叉进行的方式。在 1F1B 模式下，前向计算和反向计算交叉进行，可以及时释放不必要的中间变量。</p><p><img src="/img/pics/distributed_training/1F1B.png" alt="1F1B策略"><br>1F1B 方式相比于 F-then-B 方式，峰值显存可以节省 3/8，对比朴素流水线并行峰值显存明显下降，设备资源利用率显著提升。</p><h4 id="张量并行">张量并行</h4><p>将计算图中的层内的参数（张量）切分到不同设备（即层内并行），每个设备只拥有模型的一部分，以减少内存负荷，也就是所谓的张量模型并行。</p><p><img src="/img/pics/distributed_training/ternsor_parallelism.png" alt="tensor parallelism"></p><p><strong>从数学原理上来看就是对于linear层就是把矩阵分块进行计算，然后把结果合并；对于非linear层，则不做额外设计。</strong></p><p>张量切分方式可以分为按行切分和按列切分，对应于行并行（row parallelism）和列并行（column parallelism）.</p><p>行并行就是把权重 A 按照行分割成两部分。为了保证运算，同时我们也把 X 按照列来分割为两部分，具体如下所示：<br>$$<br>X A = \begin{bmatrix} X_1&amp;X2 \end{bmatrix}\begin{bmatrix} A_1\ A_2 \end{bmatrix} =X_1A_1+X_2A_2=Y_1+Y_2=Y<br>$$<br>这样,将 X1 和 A1 就可以放到 GPU0 之上计算得出 Y1，X2 和 A2 可以放到第二个 GPU1 之上计算得出 Y2，然后，把Y1和Y2结果相加，得到最终的输出Y。</p><p>列并行就是把 A按照列来分割，具体示例如下：<br>$$<br>X A=\begin{bmatrix} X \end{bmatrix}\begin{bmatrix} A_1 &amp; A_2 \end{bmatrix}=\begin{bmatrix} XA_1 &amp; XA_2\end{bmatrix} =\begin{bmatrix} Y_1 &amp; Y_2\end{bmatrix} =Y<br>$$<br>这样，将 X 分别放置在GPU0 和GPU1，将 A1 放置在 GPU0，将 A2 放置在 GPU1，然后分别进行矩阵运行，最终将2个GPU上面的矩阵拼接在一起，得到最终的输出Y。</p><h3 id="混合并行">混合并行</h3><p><img src="/img/pics/distributed_training/parallelism_sum.png" alt="并行方式总结"></p><p>在训练大型人工智能模型中，往往会同时面对算力不足和内存不足的问题。因此，需要混合使用数据并行和模型并行，这种方法被称为混合并行。<br><img src="/img/pics/distributed_training/mixed_parallelism.png" alt="混合并行"></p><h4 id="PP-DP">PP+DP</h4><p>将数据并行和流水线并行进行结合是常见的一种做法。<br><img src="/img/pics/distributed_training/DP+PP.png" alt="DP+PP"></p><p>在这里，DP rank 0 是看不见 GPU2 的， 同理，DP rank 1 是看不到 GPU3 的。对于 DP 而言，只有 GPU 0 和 1，并向它们供给数据。GPU0 使用 PP 将它的一些负载转移到 GPU2。同样地， GPU1 也会将它的一些负载转移到 GPU3 。</p><h4 id="3D并行（DP-PP-TP）">3D并行（DP+PP+TP）</h4><p>更高级的做法是将三种流水线方法全都结合在一起，也就是3D并行，常用在大规模的分布式集群训练当中。<br><img src="/img/pics/distributed_training/3D_parallelism.png" alt="3D并行"><br>在这种并行方式下，至少需要8个GPU设备才能够进行训练。</p><h1>key words</h1><ol><li>混合精度训练</li><li>GIL</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>分布式训练</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tranformer 原理及应用</title>
    <link href="/2025/10/03/To-know-about-Transformer/"/>
    <url>/2025/10/03/To-know-about-Transformer/</url>
    
    <content type="html"><![CDATA[<h1>Tranformer 原理及应用</h1><p>Transformer由论文《Attention is All You Need》提出，这之后这句话也是一直贯穿深度学习的研究当中。简单来说，<strong>Transformer的作用就是将一个序列转换为另一个序列，例如说中英文翻译。</strong></p><span id="more"></span><p>下图是 Transformer 用于中英文翻译的整体结构：</p><p><img src="/img/pics/transformer/transformer_struct.png" alt="example1"></p><p>在开始之前，我们需要首先知道的是transformer设计之初的目标就是用来做seq2seq任务，也就是序列转换任务。比如说定一个中文序列，它能够将其转换为一个英文序列。当然，transformer可以不止用来做翻译任务，任何可以用来转换成的seq2seq的任务都可以用transformer来完成，这也是token learning的关键。</p><h2 id="从one-hot-编码开始">从one-hot 编码开始</h2><p>假设现在我们已经有了一串待转换的序列，那么我们任务的第一步就是如何将其转换为数学可计算的，也就是将<strong>字符</strong>表示转换为<strong>数字</strong>表示。这样做的理由也很简单，因为计算机只能处理数字而不是我们人类所使用的抽象字符集。</p><p>一种简单的做法是选择一个词汇表$A$，即我们在每个序列中使用的符号集合。在一般的例子中，这将有两组不同的符号，一组用于输入序列，一组用于输出序列。</p><p>将单词转换为数字的一种方法是从 1 开始计数，为每个单词分配自己的编号。然后，单词序列可以表示为数字的列表。</p><p>例如，考虑一种词汇量大小为4的小型语言：I、apple 和 like 、banana。每个单词都可以替换为一个数字，也许 <strong>I = 1、like = 2 和 apple = 3、banana = 4。</strong> 然后，由单词序列 [ I, apple , like , banana ] 组成的句子“I like apple ”可以表示为数字序列 [1,2,3]。</p><p>尽管这样的表示方式确实可以将序列转换为数字，但是仍然不够直白，更简单的方式是<strong>one-hot编码</strong>。在 <strong>one-hot编码</strong>中，符号由一组大部分为零的向量表示，向量的长度与词汇表的长度相同，每个这样的向量都中只有一个元素的值为 1。也就是<strong>one-hot编码</strong>的向量中的每一位都代表着一个具体的单词，也就是看到一个向量，它的哪一位是1代表着它是哪一个单词。</p><p>例如在上述的例子中，<strong>one-hot编码</strong>就可以表示为：<br><img src="/img/pics/transformer/example_tra_1.png" alt="example2"></p><p>然后，“I like apple”就可以表示为一个矩阵：</p><p><img src="/img/pics/transformer/example_tra_2.png" alt="example3"></p><p>但实际上，one-hot编码真正有用的一点是它的dot product（点积，也叫标量积）操作，向量的点积即将其相应元素相乘，然后将结果相加。</p><p>独热码点积的特性：</p><ul><li>独热码与自己的点积结果为1，与其他独热码的点积结果为0</li><li>独热码与任一同维向量相乘，结果为该向量中独热码为1的位置的元素。</li></ul><p>例如：</p><p>$$<br>\vec{a} = \begin{bmatrix} 0 \ 1 \  0 \ 0 \end{bmatrix}\vec{w} = \begin{bmatrix} 0.3 \ 0.2 \  0.4 \ 0.1 \end{bmatrix}<br>$$</p><p>$$<br>\vec{a} \cdot \vec{w} = (0 * 0.3) + (1 * 0.2) + (0 * 0.4) + (0 * 0.1) = 0.2<br>$$</p><h3 id="独热码与矩阵">独热码与矩阵</h3><p>点积是矩阵乘法的基础，我们将第一个矩阵称为 A，将第二个矩阵称为 B。在最简单的情况下，当 A 只有一行且 B 只有一列时，矩阵乘法的结果是两者的点积。矩阵乘法需要满足基本要求，即维度相匹配。</p><p>当其中一个矩阵是由独热码构成时，其结果就是取出另外一个矩阵对应位置的行向量<br>例如：</p><p>$$<br>\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 0.2 \ 0.8 \ 0.9 \ 0.5\end{bmatrix}  = \begin{bmatrix} 0.8 \ 0.5\end{bmatrix}<br>$$</p><h3 id="查找表">查找表</h3><p>根据上述性质，我们就能利用独热码的矩阵乘来构建查找表。</p><p>A 矩阵由一堆 one-hot 向量组成。它们分别位于第一列、第四列和第三列。当我们进行矩阵乘法时，这将按顺序取出 B 矩阵的第一行、第四行和第三行。<strong>这种使用 one-hot 向量提取矩阵的特定行的技巧是 Transformer 工作原理的核心。</strong></p><h3 id="一阶序列转换模型">一阶序列转换模型</h3><p>现在先把矩阵放在一边，回到我们真正关心的东西，即单词序列。想象一下，假设我们在使用电脑时常用的命令有如下三种单词序列：</p><ul><li>Show me my directories please.</li><li>Show me my files please.</li><li>Show me my photos please.</li></ul><p>词汇表:</p><pre><code class="hljs">&#123;directories, files, me, my, photos, please, show&#125;</code></pre><p><strong>我们的目的是使用转换模型，对于词汇表中的每个单词，它都会显示下一个单词可能是什么</strong>那么如果用户一半时间询问照片，30% 时间询问文件，其余时间询问目录，则转换模型将如下所示。</p><table><thead><tr><th style="text-align:center"><img src="/img/pics/transformer/example_tra_3.png" alt="example4"></th></tr></thead><tbody><tr><td style="text-align:center"><em>转换模型示例图，图源 <a href="https://www.zhihu.com/question/471328838/answer/3011638037">https://www.zhihu.com/question/471328838/answer/3011638037</a></em></td></tr></tbody></table><p>这种链式的转换模型称为马尔可夫链，因为它满足<a href="">马尔可夫性质</a>，即下一个单词的概率仅取决于最近的单词。更具体地说，上述的例子是一阶马尔可夫模型，它只查看单个最近的单词。如果它考虑两个最近的单词，那就是是二阶马尔可夫模型。</p><p>马尔可夫链可以方便地用矩阵形式表示。使用与创建 one-hot 向量时相同的索引方案，每一行代表词汇表中的一个单词。每一列也是如此。每列中的值显示下一个单词出现的概率。因为矩阵中每个元素的值代表一个概率，所以它们都会落在 0 到 1 之间。由于概率总和为 1，因此每行中的值总和为 1。</p><table><thead><tr><th style="text-align:center"><img src="/img/pics/transformer/example_tra_4.png" alt="example5"></th></tr></thead><tbody><tr><td style="text-align:center"><em>马尔可夫转移矩阵 图源 <a href="https://www.zhihu.com/question/471328838/answer/3011638037">https://www.zhihu.com/question/471328838/answer/3011638037</a></em></td></tr></tbody></table><p>利用该矩阵，我们可以重新审视使用矩阵乘法与 one-hot 向量来提取与任何给定单词相关的转移概率的技巧。</p><p>例如，如果我们只是想得到每个单词出现在 my 之后的概率，我们可以创建一个代表单词 my 的 one-hot 向量，并将其乘以我们的转换矩阵。这会拉出相关行的行，并向我们显示下一个单词的概率分布。</p><table><thead><tr><th style="text-align:center"><img src="/img/pics/transformer/example_tra_5.png" alt="example6"></th></tr></thead><tbody><tr><td style="text-align:center"><em>独热码的作用 图源 <a href="https://www.zhihu.com/question/471328838/answer/3011638037">https://www.zhihu.com/question/471328838/answer/3011638037</a></em></td></tr></tbody></table><p>仅根据当前单词来预测下一个单词是很困难的。这就像在只给出第一个音符后预测一首曲子的其余部分。如果我们至少能得到两个单词来继续，我们预测的准确率就会好得多，因此我们还可以继续推广为二阶转换模型等等。</p><p><strong>到这里，我们发现我们所做的事情其实给定序列的一部分，然后预测序列的其余部分。待会儿，我们会解释为什么需要做这个。</strong></p><h3 id="Second-order-sequence-model-with-skips">Second order sequence model with skips</h3><p>二阶矩阵为每个单词组合提供单独的行。这意味着如果我们从词汇大小 N 开始，那么转换矩阵就有 N^2 行。也就是如果单词序列连续出现两个单词时，下一个单词的概率会是多少。</p><p>当我们只需回顾两个单词来决定下一个单词时，二阶模型效果很好。当我们必须进一步回顾时该怎么办？我们当然可以考虑三阶和更高阶模型。然而，由于词汇量很大，这需要非常大的计算量和存储空间来实现。八阶模型的简单实现将具有 N^8 行，这对于任何合理的词汇来说都是一个非常庞大的数字，对计算机来说也是如此。</p><p>马尔可夫链面对着这种情况就显得无能为力了，但我们仍然可以表示每对前面的单词和后面的单词之间的关系。也就是说，现在我们并不需要得到所有单词的两两配对，只需要其中一个单词是当前预测词的前一个词，另一个词就是在该词之前出现过的任何词。</p><p>举个例子来说，假设我们语料库中有两个句子：</p><ul><li>I like apple because I come from the South.</li><li>I like banana because I come from the North.</li></ul><p>现在有一个单词序列</p><pre><code class="hljs">I like apple because I come from the</code></pre><p>如何预测下一个单词出现的概率，我们就可以构建一个<em>Second order sequence model with skips</em> 进行预测，也就是如图所示：</p><p><img src="/img/pics/transformer/example_tra_6.png" alt="example7"></p><!--  more info --><p>现在，我们不再只查看一行，而是查看所有的行。每行不再代表序列在特定点的状态。相反，每一行代表可以描述特定点处的序列的许多特征之一。矩阵中的每个值不再代表概率，而是代表投票。投票将被汇总并比较以确定下一个单词的预测。也就是，当得到一个序列后，我们会对每个列向下相加求和，对于这个例子，我们计算得到<strong>South</strong>的值是4，而<strong>North</strong>的值是3，那么我们就有理由认为下一个词应该是<strong>South</strong></p><p>另一方面，我们发现4和3的差距并不够明显，倘若数据中出现噪声，很容易就会将这样的差距给掩盖，所以我们会构造掩码来选择我们需要注意的特征，对于这个例子就是只注意<em>apple</em>和<em>banana</em>，忽视其他的值，那么计算得到的结果也就是0和1，差距提升了33%.</p><p>通过计算训练中每个单词对/下一个单词转换发生的频率，可以很容易地构建特征权重，但注意力掩码却不然。实际上,这也是<strong>All you need is attention</strong>的做法，Transformer的作用之一就是训练得到这些掩码从而只关注真正有用的特征。</p><h2 id="嵌入向量">嵌入向量</h2><p>在我们一般的使用中，对于词汇量过大的词汇表，所产生的中间数据是极其庞大的，对于词汇量 N 为 50,000 的情况，所有单词对和所有潜在的下一个单词之间的转换矩阵将具有 50,000 列和 50,000 个平方（25 亿）行，总计超过 100 万亿个元素。</p><p>另一方面，为了得到稳健的语言模型，我们需要多次提供每个潜在序列的训练数据，而任何一个训练数据集都很难做到这点。</p><p>我们可以使用<strong>嵌入</strong>的方式来解决上述问题。</p><p>如上所述，在语言的独热码表示方式中，每个单词都对应一个向量元素。大小为 N 的词汇表中，该向量是一个 N 维空间。每个单词代表该空间中的一个点，沿着对应的轴移动至距原点一个单位。<br>例如:</p><p>$$<br>\vec{a} = \begin{bmatrix} 0 \ 1 \  0 \ 0 \end{bmatrix}<br>$$</p><p>a表示一个单词，是一个四维向量。</p><p>在嵌入向量中，每个独热码向量都被转换到低维空间中。例如，如果将它们嵌入到二维空间中。那么，我们不再需要 N 个数字来指定一个单词，而是只需要 2 个数字。这些是新空间中每个点的 (x, y) 坐标。</p><p>得到嵌入向量的方式很简单，对于a，只需要和一个2行4列的转换矩阵相乘即可.</p><p>$$<br>\mathbf{B} \vec{a} = \begin{bmatrix} b_{11} &amp; b_{12} &amp; b_{13} &amp; b_{14} \ b_{21} &amp; b_{22} &amp; b_{23} &amp; b_{24} \end{bmatrix} \begin{bmatrix} 0 \ 1 \  0 \ 0 \end{bmatrix} = \begin{bmatrix} b_{12} \ b_{22} \end{bmatrix}<br>$$</p><p>使用嵌入的模型可以学习嵌入空间中的模式。每个示例都能提供一点学习效果，并应用到整个单词邻域中。也就是说，一个好的嵌入模型应该将具有相似含义的词语映射到相近的空间。一般来说得到嵌入向量是需要经过训练的，而这样的嵌入模型有很多，主要又是分为两类：<strong>CBOW模型</strong>和<strong>Skipgram模型。</strong></p><p>嵌入可以大大减少所需的参数数量。然而，嵌入空间的维数越少，原始词汇的信息就会被丢弃得越多。语言的丰富性仍然需要相当大的维度来体现所有可能的语义，以免它们相互混淆，也就是需要一个有足够维度将它们分散开来的嵌入模型。我们通过选择嵌入空间的大小，尽量用计算负荷来换取模型的准确性。</p><p>在Transformer中，嵌入的过程是在这里发生的，而一般的做法是直接用训练好了的嵌入向量。：</p><img src="/img/pics/transformer/transformer_embedding.png" width="500" height="600"><h2 id="位置编码">位置编码</h2><p>在处理序列数据时，模型需要能够捕捉到序列中每个元素的位置信息，因为位置信息对于理解序列的含义和结构至关重要。普通的加一个位置信息，词量大时不利于计算，transformer里面用了一种位置编码方式，把位置信息作为词向量的一部分输入信息一起送入网络进行处理，而且获得了不错的效果。</p><p>式子如下：</p><img src="/img/pics/transformer/position_encoding.png" width="500" height="140"><p>其中：</p><p>$$<br>w_i = \frac{1}{1000^{2k/d}}<br>$$</p><p>序列中相互可以从几何上理解这种编码，单词在嵌入空间中的位置就像一个圆心。根据单词在词序中的位置，我们会对其进行扰动。在每个位置上，单词都会以不同的角度移动相同的距离，从而在单词序列中形成一个圆形图案。靠近的单词会受到相似的扰动，而相距较远的单词则会受到不同方向的扰动。</p><p>由于圆形是一个二维图形，要表示圆形摆动就需要修改嵌入空间的两个维度。如果嵌入空间包含两个以上的维度（几乎总是如此），那么圆周摆动会在所有其他维度对中重复，但角度频率不同，也就是说，每次旋转的次数不同。将所有这些不同频率的圆周摆动结合起来，就能很好地表示出单词在序列中的绝对位置。</p><p>2i 表示偶数的维度，2i+1 表示奇数维度 (即 2i≤d, 2i+1≤d)。使用这种公式计算 PE(position encoding) 有以下的好处：</p><ul><li>使 PE 能够适应比训练集里面所有句子更长的句子，假设训练集里面最长的句子是有 20 个单词，突然来了一个长度为 21 的句子，则使用公式计算的方法可以计算出第 21 位的 Embedding。</li><li>可以让模型容易地计算出相对位置，对于固定长度的间距 k，PE(pos+k) 可以用 PE(pos) 计算得到。因为 Sin(A+B) = Sin(A)Cos(B) + Cos(A)Sin(B), Cos(A+B) = Cos(A)Cos(B) - Sin(A)Sin(B)。</li><li></li></ul><p>将单词的词 Embedding 和位置 Embedding 相加，就可以得到单词的表示向量 x，x 就是 Transformer 的输入。</p><p>更详细的解释可以看参考文献中《The illustrated transformer》中对位置编码的图解。</p><p>在transformer中，位置编码的过程如下：</p><img src="/img/pics/transformer/transformer_position.png" width="500" height="600"><h2 id="Transformer的工作流程">Transformer的工作流程</h2><ul><li><strong>第一步</strong>：获取输入句子的每一个单词的表示向量 X，X由单词的 Embedding（可以理解为从原始数据提取出来的Feature） 和单词位置的 Embedding 相加得到。</li><li><strong>第二步</strong>：将得到的单词表示向量矩阵传入 Encoder 中，经过多个 Encoder block 后可以得到句子所有单词的编码信息矩阵 C。单词向量矩阵用 $X_{n\times d}$表示， n 是句子中单词个数，d 是表示向量的维度 (论文中 d=512)。每一个 Encoder block 输出的矩阵维度与输入完全一致。</li><li><strong>第三步</strong>：将 Encoder 输出的编码信息矩阵 C传递到 Decoder 中，Decoder 依次会根据当前翻译过的单词 1~i 翻译下一个单词 i+1。在使用的过程中，翻译到单词 i+1 的时候需要通过 Mask (掩盖) 操作遮盖住 i+1 之后的单词。</li></ul><h2 id="序列模型">序列模型</h2><p>Seq2Seq（Sequence-to-sequence）正如字面意思：输入一个序列，输出另一个序列，当然，其中输入序列和输出序列的长度是可变的。</p><p>针对Seq2Seq序列问题，比如翻译一句话，可以通过Encoder-Decoder模型来解决。一般这样的任务都是使用编码、解码的框架来完成，也就可以称之为Encoder-Decoder，中间一个向量C传递信息，且C的长度是固定的。<br><img src="/img/pics/transformer/seq2seq.png" alt="seq2seq"><br>为了建模序列问题，RNN引入了隐状态h（hidden state）的概念，隐状态h可以对序列形的数据提取特征，接着再转换为输出, 可以被看做是同一神经网络的多次复制，每个神经网络模块会把消息传递给下一个.</p><p>Encoder（编码器）和 Decoder（解码器）之间只有一个「向量C」来传递信息，且C的长度固定。比如翻译一段语句，翻译的句子短还好，句子一长呢？当输入句子比较长时，所有语义完全转换为一个中间语义向量C来表示，单词原始的信息已经消失，可想而知会丢失很多细节信息。所以Encoder-Decoder是有缺陷的，其缺陷在于：当输入信息太长时，会丢失掉一些信息。</p><p>而为了解决「信息过长，信息丢失」的问题，Attention 机制就应运而生了。Attention 模型的特点是 Eecoder 不再将整个输入序列编码为固定长度的「中间向量Ｃ」，而是编码成一个向量的序列。</p><h2 id="自注意力机制">自注意力机制</h2><p>自注意力层的作用是帮助编码器在对每个单词编码的时候时刻关注句子的其它单词。随着模型处理输入序列的每个单词，自注意力会关注整个输入序列的所有单词，帮助模型对本单词更好地进行编码。在处理过程中，自注意力机制会将对所有相关单词的理解融入到我们正在处理的单词中。</p><p>自注意力机制的具体功能是：</p><ul><li><strong>序列建模</strong>：自注意力可以用于序列数据（例如文本、时间序列、音频等）的建模。它可以捕捉序列中不同位置的依赖关系，从而更好地理解上下文。这对于机器翻译、文本生成、情感分析等任务非常有用。</li><li><strong>并行计算</strong>：自注意力可以并行计算，这意味着可以有效地在现代硬件上进行加速。相比于RNN和CNN等序列模型，它更容易在GPU和TPU等硬件上进行高效的训练和推理。（因为在自注意力中可以并行的计算得分）</li><li><strong>长距离依赖捕捉</strong>：传统的循环神经网络（RNN）在处理长序列时可能面临梯度消失或梯度爆炸的问题。自注意力可以更好地处理长距离依赖关系，因为它不需要按顺序处理输入序列。</li></ul><p><strong>Self-Attention 的结构:</strong></p><p><img src="/img/pics/transformer/self_attention.png" alt="example11"></p><h3 id="QKV的生成">QKV的生成</h3><p>自注意力层会从每个编码器的输入向量（每个单词的词向量，即Embedding后的结果）中生成三个向量，即<strong>查询向量、键向量和一个值向量</strong>。这三个向量是通过词嵌入与三个权重矩阵即 $W^Q , W^K , W^V$ 相乘后创建出来的。新向量在维度上往往比词嵌入向量更低。<br>将以上所得到的查询向量、键向量、值向量组合起来就可以得到三个向量矩阵，即矩阵Q(查询),K(键值),V(值)。</p><p>在实际中，Self-Attention 接收的是输入(单词的表示向量$x$组成的矩阵$X$) 或者上一个 Encoder block 的输出。而$Q,K,V$正是通过 Self-Attention 的输入进行线性变换得到的。</p><p>这里举一个简单的例子：<br>例如我们得到的一个词向量矩阵$X$，每一行都是一个单独的单词的词向量表示。那么我们可以得到：<br><img src="/img/pics/transformer/QKV.png" alt="example12"><br>Q、K、V中的每一行即为一个词向量对应的查询向量、键向量、值向量。</p><h3 id="计算注意力值">计算注意力值</h3><p>接下来，我们对每个单词需要计算其他单词对其的得分，假设我们在为这个例子中的第一个词“I”计算自注意力向量，我们需要拿输入句子中的每个单词对“I”打分。这些分数是通过所有输入句子的单词的键向量与“I”的查询向量相点积来计算的。</p><p>也就是说，对于单词“I”，我们分别需要计算$q_1\cdot k_1$, $q_1 \cdot k_2$，$q_1\cdot k_3$, $q_1 \cdot k_4$.<br>之后将分数除以$\sqrt{d}$  (d是论文中使用的键向量的维数，这可以让梯度更稳定。)<br>也就是公式：</p><p>$$<br>\frac{Q \cdot K^T}{\sqrt{d}}<br>$$</p><p>然后通过softmax传递结果。softmax的作用是使所有单词的分数归一化，得到的分数都是正值且和为1。随着模型处理输入序列的每个单词，自注意力会关注整个输入序列的所有单词，帮助模型对本单词更好地进行编码。</p><p>最后得到的结果决定了每个单词对编码当下位置（“I”）的贡献。<strong>我们可以看到，所谓并行就是指每个单词所代表的向量都可以独立地进行注意力计算得到注意力得分，而不是必须由前一个单词计算完成后才能计算下一个单词。</strong></p><h3 id="弱化无关量">弱化无关量</h3><p>直觉上我们是希望关注语义上相关的单词，并弱化不相关的单词。那么我们就需要通过在我们的值向量上乘以上述得到的注意力得分。<br>$ softmax(\frac{Q \cdot K^T}{\sqrt{d}}) $ 的结果是一个矩阵，对于这个矩阵的第i行，其上的n维对应的值，我们可以理解为其是第i个词向量与n个单词的注意力得分。</p><p>例如第i个行向量$\begin{matrix}[ a, &amp; b, &amp; c, &amp; d ]\end{matrix}$,其中$a$则表示第i个单词中与第1个单词的注意力得分，$c$则表示与第三个单词的注意力得分。<br>现在我们用这个结果来与得到的V矩阵相乘，也就相当于是对V矩阵中各个行向量进行了加权求和得到最后的结果。<br><img src="/img/pics/transformer/Z_value.png" alt="example13"></p><h2 id="多头注意力机制">多头注意力机制</h2><p>由上述推论，我们已经知道怎么通过 Self-Attention 计算得到输出矩阵 Z，而Multi-Head Attention 包含多个 Self-Attention 层，首先将输入X分别传递到 h 个不同的 Self-Attention 中，计算得到 h 个输出矩阵Z。如下图所示：</p><img src="/img/pics/transformer/multihead.png" width="500" height="500"><p>对应h=8的情况，我们最后可以得到 8 个输出矩阵，Multi-Head Attention 将它们拼接在一起 (Concat)，然后传入一个Linear层，得到 Multi-Head Attention 最终的输出Z。可以看到 Multi-Head Attention 输出的矩阵Z与其输入的矩阵X的维度是一样的。</p><img src="/img/pics/transformer/concat.png" width="800" height="400"><p>总结一下多头注意力机制的功能：</p><ul><li>扩展了模型专注于不同位置的能力。</li><li>有多个查询/键/值权重矩阵集合，并且每一个都是随机初始化的。每个注意力头都是用矩阵$X$乘以$W^Q、W^K、W^V$来产生查询、键、值矩阵。</li><li>多个注意力头会注意到不同的内容，我们对各种注意到的部分进行组合，就能避免某些可能存在的情况被忽视。</li></ul><p>具体来说，在《the illustrated transformer》中已经提到，因为不同的初始化参数，训练后得到的注意力得分是不一样的。也就意味着可能对于同一个词在不同的头上会注意到不同的位置。也就是如下图所示：<br><img src="/img/pics/transformer/multi-head-attention.png" alt="multi-head attention"><br>当计算“it”的注意力得分时，八列不同颜色的表格指示了八个头不同的注意到的位置，当对“it”一词进行编码时，一个注意力头最关注的是“animals”，而另一个是专注于“tired”——从某种意义上说，模型对“it”一词的表示在“animals”和“tired”的一些表示中提取得到。</p><h2 id="Add-Normalize">Add&amp;Normalize</h2><p>在经过多头注意力机制得到矩阵Z之后，并没有直接传入全连接神经网络，而是经过了Add&amp;Normalize层，该层由两个部分组成，即Add 和 Norm 两部分组成，其计算公式如下：</p><p>$$<br>LayerNorm(X+MultiHeadAttention(X))<br>$$</p><p>其中 X表示 Multi-Head Attention的输入，MultiHeadAttention(X) 表示输出 (输出与输入 X 维度是一样的)。</p><ul><li>Add指 X+MultiHeadAttention(X)，是一种残差连接，通常用于解决多层网络训练的问题，可以让网络只关注当前差异的部分.</li><li>Norm指 Layer Normalization，通常用于 RNN 结构，Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的，这样可以加快收敛。</li></ul><h3 id="Add">Add</h3><p>这里用到了残差连接的思想，即<br><img src="/img/pics/transformer/res_block.png" width="500" height="100"></p><p>加入残差块的目的是为了防止在深度神经网络的训练过程中发生退化的问题，退化的意思就是深度神经网络通过增加网络的层数，Loss逐渐减小，然后趋于稳定达到饱和，然后再继续增加网络层数，Loss反而增大。<br>对于多余的层，我们需要保证多出来的网络进行恒等映射。只有进行了恒等映射之后才能保证这多出来的神经网络不会影响到模型的效果。恒等映射，即让F（X）=0 就可以了。x经过线性变换（随机初始化权重一般偏向于0），输出值明显会偏向于0，而且经过激活函数Relu会将负数变为0，过滤了负数的影响。  这样当网络自己决定哪些网络层为冗余层时，使用ResNet的网络很大程度上解决了学习恒等映射的问题，<strong>用学习残差F(x)=0更新该冗余层的参数来代替学习h(x)=x更新冗余层的参数。</strong></p><h3 id="Normalize">Normalize</h3><p>归一化目的：<br>1、加快训练速度<br>2、提高训练的稳定性<br>Transformer使用到的归一化方法是<strong>Layer Normalization</strong>。</p><p>Layer Normalization（层归一化）：是在同一个样本中不同神经元之间进行归一化。</p><p>Batch Normalization（批量归一化）：是在同一个batch中不同样本之间的同一位置的神经元之间进行归一化。</p><p>层归一化的计算不依赖于其他样本，而批量归一化的计算则依赖于整个batch的样本。在处理序列数据（如文本）时，每个样本的长度可能会有所不同，这使得批量归一化在实践中难以应用。在处理变长序列时，批量归一化需要对每个序列进行填充或截断以形成一个固定大小的batch，这可能会引入额外的噪声。而层归一化则可以直接处理变长序列，不需要进行填充或截断。</p><h2 id="全连接层Feed-Forward">全连接层Feed Forward</h2><p>Feed Forward 层比较简单，是一个两层的全连接层，第一层的激活函数为 Relu，第二层不使用激活函数，对应的公式如下。</p><p>$$<br>max(0,XW_1+b_1)W_2+b_2<br>$$</p><p>也就是先线性变换，然后ReLU非线性，再线性变换。这两层网络就是为了将输入的Z映射到更加高维的空间中然后通过非线性函数ReLU进行筛选，筛选完后再变回原来的维度。</p><p>至此，一个完整的Encoder就完成了，在Transformer中总共有6个Encoder块，每一个Encoder得到的输出输入到下一个Encoder中，最终的结果在传入到Decoder中。</p><h2 id="Decoder结构">Decoder结构</h2><img src="/img/pics/transformer/transformer_decoder.png" width="500" height="600">上图红色部分为 Transformer 的 Decoder block 结构，与 Encoder block 相似，但是存在一些区别：<ul><li>包含两个 Multi-Head Attention 层。</li><li>第一个 Multi-Head Attention 层采用了 Masked 操作。</li><li>第二个 Multi-Head Attention 层的K, V矩阵使用 Encoder 的编码信息矩阵C进行计算，而Q使用上一个 Decoder block 的输出计算。</li><li>最后有一个 Softmax 层计算下一个翻译单词的概率。</li></ul><h3 id="Masked-Multi-Head-Attention">Masked Multi-Head Attention</h3><p>与Encoder的Multi-Head Attention计算原理一样，只是多加了一个mask码。mask 表示掩码，它对某些值进行掩盖，使其在参数更新时不产生效果。Transformer 模型里面涉及两种 mask，分别是 padding mask 和 sequence mask。</p><h4 id="padding-mask">padding mask</h4><p>因为每个批次输入序列长度是不一样的也就是说，我们要对输入序列进行对齐。具体来说，就是在较短的序列后面进行填充0，如果输入的序列太长，则是截取左边的内容，把多余的直接舍弃。但是这些填充的位置，其实是没什么意义的，经过softmax操作也会有对应的输出，attention机制不应该把注意力放在这些位置上，所以我们需要进行一些处理。具体的做法是，把这些位置的值加上一个非常大的负数(负无穷)，这样的话，经过 softmax，这些位置的概率就会无限接近0！</p><h4 id="sequence-mask">sequence mask</h4><p>sequence mask 是为了使得 decoder 不能看见未来的信息。对于一个序列，在 time_step 为 t 的时刻，我们的解码输出应该只能依赖于 t 时刻之前的输出，而不能依赖 t 之后的输出。因此我们需要想一个办法，把 t 之后的信息给隐藏起来。这在训练的时候有效，因为训练的时候每次我们是将target数据完整输入进decoder中地，预测时不需要，预测的时候我们只能得到前一时刻预测出的输出。具体的做法就是产生一个上三角矩阵，上三角的值全为0。把这个矩阵作用在每一个序列上，就可以达到我们的目的。</p><p>实际上，在Encoder中的Multi-Head Attention也是需要进行mask的，只不过Encoder中只需要padding mask即可，而Decoder中需要padding mask和sequence mask。</p><h3 id="Multi-Head-Attention">Multi-Head Attention</h3><p>Decoder block 第二个 Multi-Head Attention 变化不大， 主要的区别在于其中 Self-Attention 的 K, V矩阵不是使用上一个 Decoder block 的输出计算的，而是使用 Encoder 的编码信息矩阵 C 计算的。根据 Encoder 的输出 C计算得到 K, V，根据上一个 Decoder block 的输出 Z 计算 Q (如果是第一个 Decoder block 则使用输入矩阵 X 进行计算)，后续的计算方法与之前描述的一致。这样做的好处是在 Decoder 的时候，每一位单词都可以利用到 Encoder 所有单词的信息 (这些信息无需 Mask)。</p><h3 id="Softmax预测输出单词">Softmax预测输出单词</h3><p>Decoder block 最后的部分是利用 Softmax 预测下一个单词，在之前的网络层我们可以得到一个最终的输出 Z，Softmax 根据输出矩阵的每一行预测下一个单词：<br><img src="/img/pics/transformer/output.png" width="600" height="200"></p><p>具体来说，这个输出层接收 Decoder 的最后一个输出，然后通过一个全连接层（也就是一个线性变换）将其转换为一个向量，这个向量的长度等于词汇表的大小。然后，这个向量通过 Softmax 函数转换为一个概率分布。Softmax 函数可以确保所有的输出值都在 0 和 1 之间，并且所有值的总和为 1，因此可以被解释为概率。这个概率分布表示了模型对下一个词是词汇表中每个词的概率的预测。在实际应用中，我们通常选择概率最高的词作为下一个词的预测。</p><h2 id="总结">总结</h2><h3 id="数据的产生">数据的产生</h3><p>现在我们回顾一下上述的流程，首先我们介绍了独热码，这是一种用来表示不同词的手段，实际上我们一般会将其当作一个索引向量然后和嵌入矩阵相乘然后才会得到真正的词向量。注意到这里的嵌入矩阵是可以训练的，也就是说模型会通过训练从而得到更好的词向量表示，<strong>语义接近的词的词向量也会是接近的</strong>。<br>接下来，我们介绍了位置编码的嵌入，Transformer 本身是不能利用单词的顺序信息的，因此需要在输入中添加位置 Embedding。其完全基于self-attention，对于词语位置之间的信息有一定的丢失，加入了positional encoding在一定程度上能够解决这个问题。通过上述这两个过程，我们才真正得到了真正拿来训练用的数据。</p><h3 id="训练过程">训练过程</h3><p>我们以中英文翻译的任务为例子，假设我们有一一对应的中英文序列，那么我们首先会将中文序列输入到Encoder Block中，对应的英文序列输入到Decoder Block中，在这个过程中Transformer 模型可以一次处理整个序列，并且可以并行计算所有位置的输出。这是因为在训练阶段，我们已经知道整个目标序列的信息，所以可以将整个目标序列（经过 “shift right” 操作）一次性输入到 Decoder 中。</p><pre><code class="hljs">shift right&quot; 的操作是将目标序列（target sequence）向右移动一位，并在序列的开始插入一个新的符号，通常是`&lt;sos&gt;`（start of sequence）符号。这样做的目的是让模型在预测第 t 个词时，只能看到 t-1 个词，而不能看到第 t 个词和之后的词，从而确保模型在预测时不会看到未来的信息。例如，如果我们的目标序列是 [Hello, World, !, `&lt;eos&gt;`]，那么 &quot;shift right&quot; 操作后的序列就会变成 [`&lt;sos&gt;`, Hello, World, !]。这是一种技巧，用于确保当前时间步的预测不会受到未来时间步的影响。</code></pre><p>为了使训练中止，一般回收型对语句进行tokenize化，加上起始和终止的标签。这样当decoder解码到特定标签时，就知道翻译已经结束了。举个例子，比如说我们翻译&quot;I have an apple&quot;时，训练的过程中会学到单词&quot;apple&quot;之后就是终止标记，所以在推理时得到“apple”后就结束了推理过程。</p><h3 id="测试过程">测试过程</h3><p>在测试阶段，Decoder 的输入包括两部分：一部分是已经生成的目标语言的序列，另一部分是来自 Encoder 的输出。</p><p>已经生成的目标语言的序列开始时通常只包含一个开始符号 <code>&lt;sos&gt;</code>。然后，我们将这个序列和 Encoder 的输出一起输入到 Decoder 中，得到第一个词的预测。然后，我们将这个预测的词添加到目标语言的序列中，再将更新后的序列和 Encoder 的输出一起输入到 Decoder 中，得到第二个词的预测。这个过程会一直重复，直到生成一个结束符号 <code>&lt;eos&gt;</code> 或达到某个最大长度。</p><p>所以，测试阶段的 Decoder 输入是逐步生成的，每一步都依赖于前一步的输出。</p><h2 id="Transformer的应用">Transformer的应用</h2><ul><li>自然语言处理（NLP）：Transformer 在 NLP 领域的应用非常广泛，包括机器翻译、文本摘要、情感分析、命名实体识别、问答系统、对话系统等。其中，BERT、GPT、T5 等知名模型都是基于 Transformer 构建的。</li><li>语音识别：Transformer 也被用于语音识别任务，例如，将语音转换为文字。</li><li>图像处理：最近，Transformer 也开始被应用到图像处理领域，例如，ViT（Vision Transformer）模型就是用 Transformer 进行图像分类的。</li><li>生物信息学：Transformer 也被用于处理生物序列数据，例如，预测蛋白质结构。</li><li>推荐系统：Transformer 可以处理用户的行为序列，从而进行个性化推荐。</li><li>时间序列预测：Transformer 可以处理时间序列数据，用于股票预测、气候预测等任务。</li></ul><p>Transformer的主要精髓就是其提出了注意力机制，利用该机制我们可以在多种任务上取得不错的效果。</p><h2 id="以下是机器学习大作业一个使用Transformer的例子">以下是机器学习大作业一个使用Transformer的例子</h2><p><strong>题目描述：</strong></p><pre><code class="hljs">通过多模态数据（音频、文本、视频等）对会话情绪进行识别。利用给定的特征数据集，通过对三种模态数据的融合，建立稳定的情感识别模型，预测出会话时的情绪状态，包括happy,sad,angry,excited,neutral and frustrated六种情绪类别。</code></pre><p><a href="https://github.com/Jia040223/UCAS-Machine-Learning">项目参见</a></p><p>我们使用了一种基于Transformer-based编码器的模型，综合考虑数据集中的三种特征，<strong>文本、音频和图像</strong>。具体来说就是在模态编码器中引入模态内和模态间的Transformer编码器来捕获模态内和模态间的相互作用，并将位置和说话人嵌入作为这些Transformer编码器的额外输入来捕获上下文和说话人性别的信息。</p><p>在提取了话语级单模态特征后，Transformer-based模型设计了单个捕获模态内和模态间交互的模态编码器，并借鉴GRU的门控机制对输出进行处理，并拼接后通过一个线性层，得到每个模块的输出信息。然后我们通过一种分层门控融合策略，动态融合来自多种模态的信息。最后，通过一个线性映射，将每个模态的输出和融合后的分别输出映射到类别维度，后者用于得到预测情感的label，前者则与后者一起参与loss的计算.</p><img src="/img/pics/transformer/example.png" width="600" height="700"><p>实际上，在这里对transformer的使用中，并未用到解码器层,我们只使用编码器层来进行预测。</p><p>Transformer的自注意力机制天然适用于多模态信息之间的处理，所以我们是将每两个模态的特征作为输入，处理后分别作为transformer编码层的Q和K，V得到输出（一个模态的数据得到Q,K，另一个模态作为V）。这样一共会得到9个输出（一共三个模态，所以9个），下一步再把与每个模态有关的输出综合得到每个模态的最终输出，最后再综合这三个模态各自的输出，经过分类器降维后得到模型的最终输出。</p><p>最终测试的结果是：<br>基于Transformer编码器的模型的泛化能力非常好，能达70%左右的正确率，在情感识别任务中，这已经是一个非常高的正确率。我们觉得一个重要原因是Transformer的具有很强的表达能力，且其自注意力机<br>制，使得模型能够在不同位置关注输入序列的不同部分，更好地捕捉长距离依赖关系。</p><h2 id="参考文献：">参考文献：</h2><p>读到这里，本文就迎来了终点。本文参考（照抄）了网上一些优秀的Transformer讲解文章，如果感兴趣，请移步进行阅读。如果有任何问题，欢迎联系指正！</p><ol><li>Vaswani, Ashish, et al. “Attention is all you need.” Advances in neural information processing systems, 2017.</li><li><a href="https://www.zhihu.com/question/471328838/answer/3011638037">如何从浅入深理解transformer？</a></li><li><a href="https://zhuanlan.zhihu.com/p/338817680">Transformer模型详解（图解最完整版）</a></li><li><a href="https://blog.csdn.net/weixin_42475060/article/details/121101749">【超详细】【原理篇&amp;实战篇】一文读懂Transformer</a></li><li><a href="https://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></li><li><a href="https://github.com/julycoding/ChatGPT_principle_fine-tuning_code_paper/blob/main/Transformer%E9%80%9A%E4%BF%97%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%8EWord2Vec%E3%80%81Seq2Seq%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3%E5%88%B0GPT%E3%80%81BERT.md">transformer 通俗理解</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Einstein Summation Convention</title>
    <link href="/2025/10/03/Einstein-Summation-Convention/"/>
    <url>/2025/10/03/Einstein-Summation-Convention/</url>
    
    <content type="html"><![CDATA[<h1>爱因斯坦求和约定</h1><p>**爱因斯坦求和约定（Einstein Summation Convention）**是一种在数学和物理学中广泛使用的简化符号规则，特别是在张量计算和理论物理中。这个约定使得求和的过程更加简洁和直观，通常用于描述多维空间中的向量、矩阵或张量运算</p><p>在数学里，特别是将线性代数套用到物理时，爱因斯坦求和约定（Einstein summation convention）是一种标记的约定，又称为爱因斯坦标记法（Einstein notation），在处理关于坐标的方程式时非常有用。</p><h2 id="简介">简介</h2><p>按照爱因斯坦求和约定，当一个单独项目内有标号变量出现两次，一次是上标，一次是下标时，则必须总和所有这单独项目的可能值。通常而言，标号的标值为1、2、3（代表维度为三的欧几里得空间），或0、1、2、3（代表维度为四的时空或闵可夫斯基时空）。这种约定的好处是可以简化数学公式的书写，使得公式更加简洁。</p><p>具体来说：</p><ul><li>当一个索引同时出现在上标（如 $A^i$ ）和下标（如  $B_i$ ）时，表示对这个索引进行求和。例如：</li></ul><p>$$<br>A^i B_i = \sum_i A^i B_i<br>$$</p><p>这表示对于所有的  $i$ ，计算  $A^i$  和  $B_i$  的乘积并求和。</p><p>假设我们有一个向量  $A = [A^1, A^2, \dots, A^n]$  和另一个向量  $B = [B_1, B_2, \dots, B_n]$ ，它们的点积可以表示为：</p><p>$$<br>A \cdot B = A^i B_i<br>$$</p><p>按照爱因斯坦求和约定，这里隐含了对  i  从 1 到  n  的求和，即：</p><p>$$<br>A \cdot B = \sum_{i=1}^{n} A^i B_i<br>$$</p><p>!!!注意到：</p><blockquote><p>请不要将上标与指数混淆，大多数涉及到方程式都是线性的，不超过变量的一次方。</p></blockquote><h2 id="应用">应用</h2><p>torch.einsum 是一个非常强大的工具，可以用来进行各种张量运算，如矩阵乘法、转置、内积、外积等，利用简洁的字符串表示法。其优势在于，它不仅能够简洁地表达复杂的操作，还能够通过优化来提升性能，尤其是在多维数组和高维张量的操作中。</p><p><strong>语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.einsum(equation, *operands)<br></code></pre></td></tr></table></figure><ul><li>equation：一个字符串，定义了张量运算的规则。该字符串使用爱因斯坦求和约定，指示了每个输入张量的维度，以及如何进行求和操作。</li><li>*operands：一个或多个输入张量。</li></ul><h3 id="例子">例子</h3><h4 id="矩阵乘法">矩阵乘法</h4><p>对于两个矩阵  A  和  B ，其矩阵乘法可以通过 torch.einsum 表示为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.einsum(<span class="hljs-string">&#x27;ik,kj-&gt;ij&#x27;</span>, A, B)<br></code></pre></td></tr></table></figure><p>这里 <code>'ik,kj-&gt;ij'</code> 表示：</p><ul><li><strong>输入部分</strong> <code>（ik,kj）</code>：<ul><li>i 和 k 是矩阵  A  的索引，其中 i 对应  A  的行，k 对应  A  的列。</li><li>k 和 j 是矩阵  B  的索引，其中 k 对应  B  的行，j 对应  B  的列。<br>在这里，k 作为共享索引出现在了  A  和  B  中，这代表我们会对  A  中的列和  B  中的行进行求和（也就是矩阵乘法中的点积）。</li></ul></li><li><strong>箭头部分</strong> <code>-&gt;ij</code>：<ul><li>i 对应矩阵  A  的行索引。</li><li>j 对应矩阵  B  的列索引。<br>箭头后的部分指定了输出张量  C  的维度（即结果矩阵的维度），因此这里 ij 表示输出矩阵  C  的维度将是  $m \times p$ ，即矩阵  A  的行数和矩阵  B  的列数。</li></ul></li></ul><p>也就是说，对于矩阵  A  中的每个行索引  i  和列索引  k ，以及矩阵  B  中的行索引  k  和列索引  j ，我们计算这些索引相同的元素的乘积，并对  k  进行求和（即矩阵乘法中的点积）。</p><p>对于复杂一点的例子，比如高纬度的张量运算，torch.einsum 也能够轻松应对。</p><h4 id="批量矩阵乘法">批量矩阵乘法</h4><p>对于批量矩阵乘法，假设  A  和  B  是三维张量，可以使用如下表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">C[b, i, j] = <span class="hljs-built_in">sum</span>(A[b, i, k] * B[b, k, j] over k)<br><br><span class="hljs-comment"># torch.einsum 表达式</span><br>torch.einsum(<span class="hljs-string">&#x27;bik,bkj-&gt;bij&#x27;</span>, A, B)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算术约定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prometheus介绍</title>
    <link href="/2025/10/03/Prometheus/"/>
    <url>/2025/10/03/Prometheus/</url>
    
    <content type="html"><![CDATA[<h1>Prometheus介绍</h1><h2 id="介绍">介绍</h2><p>PrometheusPrometheus 是一个系统监控和警报系统。简单来说，就是一个存储时间序列数据的数据库，Prometheus 将所有metric data存储为时间序列，即将系统的度量信息与记录的时间戳一起存储。</p><pre><code class="hljs">Metric data（度量数据）是指用于量化和监测系统、应用程序或服务的性能和健康状态的数据。这类数据通常是通过定期收集和记录的指标，旨在帮助开发者和运维人员了解系统的运行状况、识别潜在问题并进行性能优化。</code></pre><p>Prometheus是继Kubernetes之后的第二款加入CNCF的开源软件。</p><h2 id="基本架构">基本架构</h2><p>prometheus的基础组件为：</p><ul><li>Prometheus Server,用于抓取和存储metrics data</li><li>Targets to be scraped，例如能展示其指标的应用程序，或者能导出其他应用程序指标的程序。</li><li>Alertmanager,用于通过预先设置的规则产生告警（一旦metric data出现不符合预期的数据）<br><img src="/img/pics//Prometheus/architecture.png" alt="Architecture"></li></ul><p>例子，假设有一个web服务器作为目标对象，我们想要提取其中的一个指标，比如说web服务器处理的API调用数量。那么通过在Prometheus在web服务器上加入一些instrumentation code（监控代码）来定义和记录指标，并使之公开指标信息。</p><p>Web 服务器会将这些指标信息暴露为一个 HTTP 端点（通常是 /metrics），供 Prometheus 访问。接下来我们就可以通过配置 Prometheus，在 Prometheus 的配置文件中，设置要抓取的 Web 服务器的 IP 地址和端口，并指定抓取的时间间隔（例如每分钟）。抓取指标：Prometheus 会按照配置的时间间隔定期请求 Web 服务器的指标端点，从而获取和存储这些指标数据。以此类推，我们可以创建并抓取多个指标来了解应用程序的运行状态，并根据其创建多个图表。</p><h2 id="metircs-数据类型">metircs 数据类型</h2><p>Prometheus共支持四种类型的metrics，分别是Counter,Gauge,Histogram,Summary.</p><ul><li>Counter<br>Counter是一种指标值，其只增不减除非被重置。Counter只能用在例如请求次数，错误次数之类的指标。</li><li>Gauge<br>Gauge是一种可增可减的数，因此可以被用在例如节点数量、队列中事件数目等的指标。</li><li>Histogram<br>Histogram 是一种用于收集和分析度量数据的更为复杂的指标类型。它通过将测量值（如请求处理时间）分配到预定义的**桶（buckets）**中，从而提供了对数据分布的更深入分析。</li><li>Summary<br>Summaries也可以用来测量事件，并可以作为Histogram的替代品。Summaries更加轻量，但同时也会损失更多的数据。Summary是在应用层的级别上计算的，意味着它不会同时去维护多个微服务实例，只能提供单一实例的局部信息。</li></ul><h2 id="可视化指标">可视化指标</h2><p>Grafana是一款开源的数据可视化和监控工具，广泛用于监控和分析系统和应用程序的性能。通过Grafana，用户可以创建、浏览和共享数据的可视化仪表板，这些仪表板可以实时显示数据，并帮助用户识别和解决问题。我们可以将prometheus接入到grafana中来将获得的metric data进行可视化。</p><p>在 Grafana 中，<a href="http://localhost:9090">http://localhost:9090</a> 通常指的是 Prometheus 的默认 HTTP API 接口。通过grafana接入到这个接口，grafana就可以查看prometheus存储的数据。grafana提供了dashboard来自定义我们对数据的可视化方式，例如折线图、扇形图和热图等。</p><h2 id="告警（alert）">告警（alert）</h2><p>利用prometheus采集存储到的指标，我们可以定义规则来产生告警。例如说，当一些指标高过某个阈值时，prometheus就会通过Alertmanager产生告警。Alertmanager支持一系列的接收器（例如email,webhook,pagerduty,slack等），当产生告警时，它就会发送到对应的接收器上。</p><h1>Prometheus教程</h1><p>我们可以从两个角度来学习Prometheus，一个是搭建和配置Promethus，另一个就是将其当作一个metricstore来使用。这里主要关注对其的使用，主要对这个数据库的查询。</p><h2 id="Data-Model">Data Model</h2><p>如上所述，prometheus主要是存储时间序列数据，即属于同一指标和同一组标注维度的时间戳数据。除了这些时间序列外，prometheus可能还会因为查询生成临时的时间序列（例如某几个时间序列的聚合）</p><h2 id="Metric">Metric</h2><p>这里继续详细介绍一下prometheus中的metric.每个时间序列都是被唯一的metric name(指标名称)和一些可选的键值对（称之为labels）所标识。</p><p><strong>Metric names</strong>:</p><ul><li>指定要测量的系统的一般特征（例如，http_requests_total - 收到的 HTTP 请求总数）。</li><li>度量名称可包含 ASCII 字母、数字、下划线和冒号。它必须匹配 <code>regex [a-zA-Z_:][a-zA-Z0-9_:]*</code>。</li></ul><p>注意：冒号是为用户定义的记录规则保留的。</p><p><strong>Metric labels</strong>：</p><ul><li>使 Prometheus 的维度数据模型能够识别同一度量名称的任何给定标签组合。它可识别该度量的特定维度实例（例如：使用 POST 方法向 /api/tracks 处理程序发送的所有 HTTP 请求）。查询语言允许根据这些维度进行过滤和聚合。</li><li>更改任何标签的值，包括添加或删除标签，都将创建一个新的时间序列。</li><li>标签可包含 ASCII 字母、数字和下划线。它们必须与<code> regex [a-zA-Z_][a-zA-Z0-9_]*</code> 匹配。</li><li>以 __（两个“_”）开头的标签名称保留供内部使用。</li><li>标签值可包含任何 Unicode 字符。</li><li>标签值为空的标签等同于不存在的标签。</li></ul><p>在prometheus中，<strong>Samples</strong>就是指从真实时间序列中采样到的样本数据，每个样本都包括一个64位浮点数据和一个毫秒级精度的时间戳。</p><p>例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">metric</span> <span class="hljs-attr">name</span>&gt;</span>&#123;<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">name</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">value</span>&gt;</span>, ...&#125;<br></code></pre></td></tr></table></figure><p>就是指定来一个唯一的时间序列，例如, metric name 为api_http_requests_total 并且 labels 为method=“POST” and handler=“/messages” 的时间序列数据可能是这样：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">api_http_requests_total&#123;method=<span class="hljs-string">&quot;<span class="hljs-keyword">POST</span>&quot;</span>, handler=<span class="hljs-string">&quot;/messages&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="jobs-and-instances">jobs and instances</h2><p>在prometheus的术语中，一个可以抓取指标数据的端点称之为一个instance，通常对应于一个单独独进程。而一系列相同目的instance的集合（为提高可扩展性或可靠性而复制的进程）就称为一个job.</p><p>例子：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">job: api-server<br>   <span class="hljs-built_in"> instance </span>1: 1.2.3.4:5670<br>   <span class="hljs-built_in"> instance </span>2: 1.2.3.4:5671<br>   <span class="hljs-built_in"> instance </span>3: 5.6.7.8:5670<br>   <span class="hljs-built_in"> instance </span>4: 5.6.7.8:5671<br></code></pre></td></tr></table></figure><p>prometheus可以自动地定义时间序列的labels来指示所抓取的对象。</p><h1>PromQL语法</h1><p>PromQL是prometheus提供的一种功能查询语言，能够帮助用户实时选择和聚合时间序列数据。PromQL查询到的结果可以被一个外部系统通过HTTP API进行调用。</p><h2 id="基本原理">基本原理</h2><p>PromQL中，一个表达式/子表达式计算得到的四种结果类型：</p><ul><li>Instant vetccor: 是 一组时间序列，每个时间序列包含一个样本，所有时间序列共享相同的时间戳</li><li>Range vector:  一组时间序列，其中包含每个时间序列随时间变化的一系列数据点</li><li>Scalar: 一个简单的浮点值</li><li>String: 一个简单的字符串值；一般不使用</li></ul><p>根据使用的情况，只有一些类型作为用户指定的表达式结果的时候才是合法的。（唯一能够绘制图表的类型就是Instant vector）。</p><h2 id="Literals">Literals</h2><h3 id="String-literals">String literals</h3><p>字符串由单引号，双引号或者反引号指定。PromQL 遵循与 Go 相同的转义规则。对于单引号或双引号中的字符串文字，反斜杠开始转义序列，后面可能跟着 a、b、f、n、r、t、v 或 \。可以使用八进制 (\nnn) 或十六进制（\xnn、\unnnn 和 \Unnnnnnnn）表示法提供特定字符。</p><p>相反，反引号指定的字符串文字中的转义字符不会被解析。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">&quot;this is a string&quot;<br>&#x27;these are unescaped: <span class="hljs-symbol">\n</span> <span class="hljs-symbol">\\</span> <span class="hljs-symbol">\t</span>&#x27;<br>`these are not unescaped: <span class="hljs-symbol">\n</span> &#x27; &quot; <span class="hljs-symbol">\t</span>`<br></code></pre></td></tr></table></figure><h3 id="Float-literals">Float literals</h3><p>浮点数标量值可以按以下格式写入文字整数或浮点数（仅包含空格是为了提高可读性）：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[-+]</span>?(<br>      <span class="hljs-comment">[0-9]</span>*\.?<span class="hljs-comment">[0-9]</span>+(<span class="hljs-comment">[eE]</span><span class="hljs-comment">[-+]</span>?<span class="hljs-comment">[0-9]</span>+)?<br>    | 0<span class="hljs-comment">[xX]</span><span class="hljs-comment">[0-9a-fA-F]</span>+<br>    | <span class="hljs-comment">[nN]</span><span class="hljs-comment">[aA]</span><span class="hljs-comment">[nN]</span><br>    | <span class="hljs-comment">[iI]</span><span class="hljs-comment">[nN]</span><span class="hljs-comment">[fF]</span><br>)<br></code></pre></td></tr></table></figure><h2 id="Time-series-selectors">Time series selectors</h2><p>时间序列selector负责选择时间序列以及原始或推断的样本时间戳和值。</p><h3 id="Instant-vector-selectors">Instant vector selectors</h3><p>Instant vector selectors允许在给定时间戳（时间点）选择一组时间序列和每个时间序列的单个样本值。在最简单的形式中，仅指定指标名称，这会生成一个即时向量，其中包含具有该指标名称的所有时间序列的元素。</p><p>例如一个具有 http_requests_total 指标名称的所有时间序列：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">http_requests_total</span><br></code></pre></td></tr></table></figure><p>可以通过在大括号 (<code>&#123;&#125;</code>) 中附加以逗号分隔的标签匹配器列表来进一步过滤这些时间序列。</p><p>例如具有 ````http_requests_total<code> 指标名称且</code>job<code>标签设置为 prometheus， 且</code>group```标签设置为 canary 的时间序列：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">http_requests_total&#123;job=<span class="hljs-string">&quot;prometheus&quot;</span>,<span class="hljs-keyword">group</span>=<span class="hljs-string">&quot;canary&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>还可以对标签值进行负匹配，或者将标签值与正则表达式进行匹配。存在以下标签匹配运算符：</p><ul><li>=：选择与提供的字符串完全相同的标签。</li><li>!=：选择不等于提供的字符串的标签。</li><li>=~：选择与提供的字符串正则表达式匹配的标签。</li><li>!~：选择与提供的字符串正则表达式不匹配的标签。</li></ul><p><strong>正则表达式匹配是完全锚定的。 env=~“foo” 的匹配被视为 env=~“^foo$”。</strong></p><p>例如，选择用于暂存、测试和开发环境的所有 http_requests_total 时间序列以及除 GET 之外的 HTTP 方法。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">http_requests_total&#123;environment=~<span class="hljs-string">&quot;staging|testing|development&quot;</span>,<span class="hljs-keyword">method!</span>=<span class="hljs-string">&quot;GET&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>匹配空标签值的标签匹配器还会选择根本没有特定标签集的所有时间序列。</p><p>例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">http_requests_total<br>http_requests_total&#123;<span class="hljs-keyword">replica</span>=&quot;rep-a&quot;&#125;<br>http_requests_total&#123;<span class="hljs-keyword">replica</span>=&quot;rep-b&quot;&#125;<br>http_requests_total&#123;环境=“开发”&#125;<br></code></pre></td></tr></table></figure><p>查询<code>http_requests_total&#123;environment=&quot;&quot;&#125;</code>将匹配并返回：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">http_requests_total<br>http_requests_total&#123;<span class="hljs-keyword">replica</span>=&quot;rep-a&quot;&#125;<br>http_requests_total&#123;<span class="hljs-keyword">replica</span>=&quot;rep-b&quot;&#125;<br></code></pre></td></tr></table></figure><p>并排除：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">http_requests_total&#123;<span class="hljs-attribute">environment</span>=“development”&#125;<br></code></pre></td></tr></table></figure><p>同一标签名可​​以使用多个匹配器。(<strong>都必须通过才能返回结果。</strong>)</p><p>查询：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">http_requests_total&#123;<span class="hljs-keyword">replica</span>!=&quot;rep-a&quot;,<span class="hljs-keyword">replica</span>=~&quot;rep.*&quot;&#125;<br></code></pre></td></tr></table></figure><p>然后会匹配：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">http_requests_total&#123;<span class="hljs-keyword">replica</span>=&quot;rep-b&quot;&#125;<br></code></pre></td></tr></table></figure><p>vector selector 必须指定一个名称或至少一个与空字符串不匹配的标签匹配器。以下表达式是非法的：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">&#123;<span class="hljs-keyword">job</span>=~<span class="hljs-string">&quot;.*&quot;</span>&#125; <br></code></pre></td></tr></table></figure><p>标签匹配器还可以通过匹配内部 __name__ 标签来应用于指标名称。例如，表达式 <code>http_requests_total </code>相当于 <code>&#123;__name__=&quot;http_requests_total&quot;&#125;</code>。也可以使用 = (!=, =~, !~) 以外的匹配器。以下表达式选择名称以 job: 开头的所有指标：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;__name__<span class="hljs-punctuation">=</span><span class="hljs-symbol">~&quot;work</span>:.*<span class="hljs-string">&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>指标名称不能是关键字 bool、on、ignoring、group_left 和 group_right 之一。以下表达式是非法的：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">on</span>&#123;&#125; <br></code></pre></td></tr></table></figure><h3 id="Range-Vector-selectors">Range Vector selectors</h3><p>Range vector literal的工作方式与Instant vector literal类似，只不过它们选择从当前时刻返回的一系列样本。</p><p>从语法上讲，持续时间附加在vector selectors末尾的方括号 ([]) 中，以指定应为每个结果范围。该范围是一个闭区间。</p><p>例如择过去 5 分钟内为指标名称为 http_requests_total 且job标签设置为 prometheus 的所有时间序列记录的所有值：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">http_requests_total&#123;job<span class="hljs-operator">=</span><span class="hljs-string">&quot;prometheus&quot;</span>&#125;[<span class="hljs-number">5</span>m]<br></code></pre></td></tr></table></figure><h3 id="time-durations">time durations</h3><p>Time durations 指定为数字，并跟上时间单位：</p><ul><li>ms,毫秒</li><li>s,秒</li><li>m,分钟</li><li>h,小时</li><li>d,天，认为一天24h</li><li>w,周，一周7天</li><li>y,年，一年365天</li></ul><p>持续时间可以通过串联来组合。单位必须按照从最长到最短的顺序排列。给定单位在一段时间内只能出现一次。</p><p>以下是有效持续时间的一些示例：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">5</span><span class="hljs-built_in">h</span><br><span class="hljs-number">1</span>h30m<br><span class="hljs-number">5</span>m<br><span class="hljs-number">10</span>s<br></code></pre></td></tr></table></figure><h3 id="offset-modifier">offset modifier</h3><figure class="highlight plaintext"><figcaption><span>modifier允许改变单个Instant vector和Range vector的时间偏移。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs offset```">例如说，返回相对于当前查询评估时间过去 5 分钟的 http_requests_total 值：<br></code></pre></td></tr></table></figure><p>http_requests_total offset 5m</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">请注意，<span class="hljs-built_in">offset</span> modifier始终需要紧跟在selector后面，即以下内容是正确的：<br></code></pre></td></tr></table></figure><p>sum(http_requests_total{method=“GET”} offset 5m)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">以下格式是不正确的：<br></code></pre></td></tr></table></figure><p>sum(http_requests_total{method=“GET”}) offset 5m // 无效。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap"><br>这同样适用于范围向量。<br><br>例如将返回 http_requests_total 一周前的<span class="hljs-number"> 5 </span>分钟速率：<br></code></pre></td></tr></table></figure><p>rate(http_requests_total[5m] offset 1w)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当查询过去的样本时，负偏移量将启用时间向前的比较：<br></code></pre></td></tr></table></figure><p>rate（http_requests_total[5m] offset -1w）</p><pre><code class="hljs"></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Prometheus,时序数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算图概述</title>
    <link href="/2025/10/03/computional-graph/"/>
    <url>/2025/10/03/computional-graph/</url>
    
    <content type="html"><![CDATA[<h1>Computational Graph</h1><h2 id="Background">Background</h2><p>早期的机器学习框架主要是针对较为简单的全连接（e.g FNN）和卷积神经网络设计，这些神经网络模型的结构比较简单，神经网络层之间串行连接，我们很容易分析出数据流过神经网络模型时的计算过程。因此，这样的固定计算过程可以用简单的配置文件来定义，一旦给定这样的配置文件，我们就可以清楚地表达出模型定义。</p><p>随着日益复杂的机器学习模型的出现（生成对抗网络、注意力模型等），不能再通过简单地直接定义算子的使用过程来表达一个模型（例如带有分支和循环的结构的模型）。机器学习框架需要能够高效分析出算子的执行依赖关系，并进行梯度计算及管理训练参数，以优化计算策略和自动化梯度计算。<strong>计算图</strong>就是这样一个通用的数据结构来理解、表达和执行机器学习模型，提高机器学习框架训练复杂模型的效率。</p><h2 id="Composition-of-computational-graph">Composition of computational graph</h2><p>计算图的基本构成是基本数据结构张量（tensor）和基本运算单元算子构成。</p><pre><code class="hljs">算子包括很多类型：算子是构建神经网络的基础，可以理解为一种低级API。通过对算子的封装可以实现各类神经网络层，当开发神经网络层遇到内置算子无法满足时，就可以使用自定义算子来实现。它们可以对张量数据进行加工处理，实现机器学习中的各种常用的计算逻辑。可以按照功能将算子分为：张量操作算子、神经网络算子、数据流算子和控制流算子等。例如卷积（convolution）、池化（pooling）、全连接（Fully Connected）等。</code></pre><p>计算图中使用节点来表示算子，节点间的有向边来表示张量的状态，也描述了算子间的依赖关系。<br><img src="/img/pics/computional_graph/simple_cg.png" alt="simple computational graph"></p><h3 id="张量">张量</h3><p>张量其实就是指多维数据，使用秩来表示张量的维度。例如，标量为0维张量，向量为一维张量。在一般的机器学习框架中，张量不仅需要存储数据，还需要存储张量的数据形状、数据类型、秩、存储位置和梯度传递状态等多个属性。</p><p>一般来说，在机器学习的环境下，张量的形状一般是“整齐”的，也就是每个轴具有相同的元素个数（e.g 一个矩形/一个立方体），而有时为了节省内存也会使用不规则张量和稀疏张量。<br><img src="/img/pics/computional_graph/tensor_type.png" alt="tensor kind"></p><pre><code class="hljs">稀疏张量一般应用在图数据与图神经网络中，采用特殊的存储格式（如coordinate list,COO），高效存储稀疏数据以节省存储空间。</code></pre><h2 id="Calculate-dependencies">Calculate dependencies</h2><p>计算图存在依赖关系，这种依赖关系影响的是算子的执行顺序与并行情况。<strong>循环依赖</strong>的数据流向在机器学习算法中是不被允许的，它会形成计算逻辑上的死循环，使得模型的训练程序无法正常结束，造成数据趋向于无穷大或者0成为无效数据。<br><img src="/img/pics/computional_graph/caculate_dependency.png" alt="caculate dependency"><br>根据依赖关系，我们可以知道某些节点必须等待其前继节点的计算任务完成后才能开始，因此需要避免此类节点之前的节点被删除或更改。</p><h2 id="Cyclic-unfolding">Cyclic unfolding</h2><p>对于存在循环关系的计算图，一般使用展开机制来实现。<br><img src="/img/pics/computional_graph/cyclic_unfolding.png" alt="cyclic unfolding"><br>循环体中的计算子图会按照迭代次数进行复制，将展开的子图进行串联，相邻迭代轮次的计算子图是直接依赖的关系。由于在计算图中，每一个张量和运算符都有唯一的标识符，即使是相同的运算符在不同迭代的计算任务中也会有不同的标识符。这样可以对展开后的子图中的计算节点赋予独特的标识符来避免循环依赖。</p><h2 id="Control-flow">Control flow</h2><p>通过控制流可以设定特定的顺序来执行计算任务，让某些计算节点执行任意次数或者根据条件判断某些节点不执行。常见的控制流分为条件分支和循环两种，当模型包含控制流时，梯度在反向传播时应能在反向梯度计算图中也构造出相应的控制流，才能正确地计算参与运算的张量的梯度。<br><img src="/img/pics/computional_graph/control_flow.png" alt="control flow"><br>可以想到，当模型中含有循环控制时，每一次的循环都依赖于前一次循环的计算结构，所以循环控制中还需要维护一个张量列表用来将循环迭代中的中间结果缓存起来，用来参与前向计算和梯度计算。</p><h1>generation of computational graph</h1><p>在机器学习框架中，计算图可以分为静态图和动态图两种。</p><p><strong>静态图</strong>：静态生成可以根据前段语言描述的神经网络拓扑结构以及参数变量信息来进行构建，静态图执行期间可以不依赖前端语言描述，因此常用于模型部署。</p><p><strong>动态图</strong>：动态图在每一次执行神经网络模型时都需要依据前段语言描述生成一份临时的计算图，因此计算图的动态生成过程灵活可变，有助于神经网络结构的调整。</p><h2 id="static-generation">static generation</h2><p>静态的计算图的生成与执行采用先编译后执行的方式，将图的定义和执行分离。<br><img src="/img/pics/computional_graph/static%20graph.png" alt="static graph"><br>前端语言定义模型后，机器学习框架会首先对神经网络模型进行分析，获取网络层之间的拓扑关系以及参数变量设置、损失函数等信息。然后框架会将完整的模型编译为可被后段计算硬件调用执行的固定代码文本，也即静态计算图。</p><p>当使用静态计算图进行模型训练或者推理时，无需再编译前端语言模型。<strong>静态计算图直接接收数据并通过相应硬件调度来执行图中的算子完成任务。</strong></p><pre><code class="hljs">机器学习框架在进行静态编译时并不读取输入数据，而是使用一种特殊的张量来表示输入数据，辅助构建完整的计算图，这种特殊张量也就被称为：数据占位符（placeholder）.所谓的数据占位符其实就是定义的数据变量（e.g X Y）。前端定义需要声明并编写包含数据占位符、损失函数、优化函数、网络编译和执行环境以及网络执行器等在内的预定义配置项。</code></pre><p>静态计算图的优势在于<strong>计算性能</strong>和<strong>直接部署</strong>。静态图在机器学习框架编译时就能够获取模型完整的图拓扑关系。而掌握全局信息则更容易制定计算图的优化策略。部署模型进行应用时，可以将静态计算图序列化保存，这在模型推理时就可以执行序列化的模型而不必再重新编译前端语言代码。</p><h3 id="disadvantages">disadvantages</h3><p>前端语言构建的神经网络模型经过编译后，计算图的结构就会固定执行且不再改变，经过优化后的用于执行的静态图代码也与原始代码存在较大差距。因此，在执行过程中发生错误时，会返回优化后代码出错的位置，用户难以查看优化后的代码，这会增大代码调试的难度。</p><h2 id="dynamic-generation">dynamic generation</h2><p>动态图采用解析式的执行模型，其核心特点是编译与执行同时发生。<br><img src="/img/pics/computional_graph/dynamic_graph.png" alt="dynamic graph"><br>动态图会采用前端语言自身的解释器来对代码进行解析，利用机器学习框架本身的算子分发功能，即刻执行并输出输出结果。该过程并不产生静态的计算图，而是按照前端语言描述模型结构，按照计算依赖关系进行调度执行，动态生成临时的图拓扑结构。</p><p><img src="/img/pics/computional_graph/dynamic_generation.png" alt="dynamic gerneration"><br>具体来说，神经网络前向计算按照模型声明定义的顺序进行执行。当模型接收输入数据<strong>X</strong>后，机器学习框架开始动态生成图拓扑结构，添加输入节点并准备将数据传输给后续节点。当模型中存在条件控制时，动态图模式下会即刻得到逻辑判断结果并确定数据流向。机器学习框架会在添加节点的同时完成算子分发计算并返回计算结果，同时做好准备向后续添加的节点传输数据。<strong>当模型再次进行前向计算时，动态生成的图结构则失效，并再次根据输入和控制条件生成新的图结构</strong>。相比于静态生成，可以发现动态生成的图结构并不能完整表示前端语言描述的模型结构，需要即时根据控制条件和数据流向产生图结构。由于机器学习框架无法通过动态生成获取完整的模型结构，因此动态图模式下难以进行模型优化以提高计算效率。</p><p>在静态生成方式下，由于已经获取完整的神经网络模型定义，因此可以同时构建出完整的前向计算图和反向计算图。而在动态生成中，由于边解析边执行的特性，反向梯度计算的构建随着前向计算调用而进行。在执行前向过程中，机器学习框架根据前向算子的调用信息，记录对应的反向算子信息以及参与梯度计算的张量信息。前向计算完毕之后，反向算子与张量信息随之完成记录，机器学习框架会根据前向动态图拓扑结构，将所有反向过程串联起来形成整体反向计算图。最终，将反向图在计算硬件上执行计算得到梯度用于参数更新。</p><p>尽管动态生成中完整的网络结构在执行前是未知的，不能使用静态图中的图优化技术来提高计算执行性能。但其即刻算子调用与计算的能力，使得模型代码在运行的时候，每执行一句就会立即进行运算并会返回具体的值，方便开发者在模型构建优化过程中进行错误分析、结果查看等调试工作。</p><h1>Advanced tool</h1><p>目前TensorFlow、MindSpore、PyTorch、PaddlePaddle等主流机器学习框架为了兼顾动态图易用性和静态图执行性能高效两方面优势，均具备动态图转静态图的功能，支持使用动态图编写代码，框架自动转换为静态图网络结构执行计算。</p><p>动态图转换为静态图的实现方式有两种：</p><ul><li>基于追踪转换：以动态图模式执行并记录调度的算子，构建和保存为静态图模型。</li><li>基于源码转换：分析前端代码来将动态图代码自动转写为静态图代码，并在底层自动帮用户使用静态图执行器运行。</li></ul><h2 id="trace-transition">trace transition</h2><p>基于追踪转换的原理相对简单，当使用动态图模式构建好网络后，使用追踪进行转换将分为两个阶段。</p><p>第一个阶段与动态生成原理相同，机器学习框架创建并运行动态图代码，自动追踪数据流的流动以及算子的调度，将所有的算子捕获并根据调度顺序构建静态图模型。与动态生成不同的地方在于机器学习框架并不会销毁构建好的图，而是将其保存为静态图留待后续执行计算。</p><p>第二个阶段，当执行完一次动态图后，机器学习框架已生成静态图，当再次调用相同的模型时，机器学习框架会自动指向静态图模型执行计算。追踪技术只是记录第一次执行动态图时调度的算子，但若是模型中存在依赖于中间结果的条件分支控制流，只能追踪到根据第一次执行时触发的分支。**此时构建的静态图模型并不是完整的，缺失了数据未流向的其他分支。**在后续的调用中，因为静态模型已无法再改变，若计算过程中数据流向缺失分支会导致模型运行错误。同样的，依赖于中间数据结果的循环控制也无法追踪到全部的迭代状态。</p><h2 id="code-transition">code transition</h2><p>基于源码转换的方式则能够改善基于追踪转换的缺陷。基于源码转换的流程经历两个阶段。</p><p>第一个阶段，对动态图模式下的代码扫描进行词法分析，通过词法分析器分析源代码中的所有字符，对代码进行分割并移除空白符、注释等，将所有的单词或字符都转化成符合规范的词法单元列表。接着进行语法分析即解析器，将得到的词法单元列表转换成树形式，并对语法进行检查避免错误。</p><p>第二阶段，动态图转静态图的核心部分就是对抽象语法树进行转写，机器学习框架中对每一个需要转换的语法都预设有转换器，每一个转换器对语法树进行扫描改写，将动态图代码语法映射为静态图代码语法。其中最为重要的前端语言控制流，会在这一阶段分析转换为静态图接口进行实现，也就避免了基于追踪转换中控制流缺失的情况。转写完毕之后，即可从新的语法树还原出可执行的静态图代码.</p><h1>Sceduler of computational graph</h1><p>模型的训练过程就是计算图中算子的调度执行过程。宏观来看训练任务是由设定好的训练迭代次数来循环执行计算图，此时需要优化迭代训练计算图过程中数据流载入和训练（推理）执行等多个任务之间的调度策略。微观上单次迭代需要考虑计算图内部的调度执行问题，根据计算图结构、计算依赖关系、计算控制分析算子的执行调度。</p><h2 id="Execute">Execute</h2><p>算子的调度执行包含两个步骤：</p><ul><li>第一步，根据拓扑排序算法，将计算图进行拓扑排序得到线性算子调度序列；</li><li>第二步，将序列中国的算子分配到指令流进行计算，并尽可能并行计算。</li></ul><p>我们已经知道，计算图是一种由依赖边和算子构成的有向无环图，必须保证算子执行时的依赖关系不被打破。</p><p><img src="/img/pics/computional_graph/cg_execute.png" alt="算子执行调度"></p><pre><code class="hljs">拓扑排序就是不断将入度为0的节点取出放入队列中直至有向无环图中的全部节点都加入到队列中。</code></pre><p>生成调度序列之后，需要将序列中的算子与数据分发到指定的GPU/NPU上执行运算。根据算子依赖关系和计算设备数量，可以将无相互依赖关系的算子分发到不同的计算设备，同时执行运算，这一过程称之为并行计算，与之相对应的按照序贯顺序在同一设备执行运算被称为串行计算。</p><h2 id="Serial-and-parallel">Serial and parallel</h2><ul><li><strong>串行</strong>：队列中的任务必须按照顺序进行调度执行直至任务队列结束、</li><li><strong>并行</strong>：队列中的任务可以同时进行调度执行，加快执行效率。</li></ul><h3 id="Serial">Serial</h3><p>微观上。计算图中大多数算子之间存在直接依赖或者间接依赖关系，具有依赖关系的算子间任务调度则必定存在执行前后的时间顺序。算子的执行队列只能以串行的方式进行调度，保证算子都能正确接受到输入数据，才能完成计算图的一次完整执行。</p><p>宏观上，每一轮迭代中计算图必须读取训练数据，执行完整的前向计算和反向梯度计算，将图中所有参数值更新完毕后，才能开始下一轮的计算图迭代计算更新。所以“数据载入-数据预处理-模型训练”的计算图整体任务调度是以串行方式进行的。</p><h3 id="Parallel">Parallel</h3><p>计算图内部，算子除了直接依赖和间接依赖之外，还存在算子间相互独立的情况。此时可以将算子分配到不同的硬件上进行并行计算。<strong>并行包括算子并行、模型并行以及数据并行</strong>。</p><ul><li>算子并行不仅可以在相互独立的算子间实现，同时也可以将单个算子合理的切分为相互独立的多个子操作，进一步提高并行性。</li><li>模型并行就是将整体计算图进行合理的切分，分配到不同设备上进行并行计算，缩短单次计算图迭代训练时间。</li><li>数据并行则同时以不同的数据训练多个相同结构的计算图，减少训练迭代次数，加快训练效率。</li></ul><h2 id="Synchronous-and-asynchronous">Synchronous and asynchronous</h2><p>我们可以将一次完整计算图的训练执行过程分为三个阶段：数据载入、数据预处理和网络训练。这三个环节之间的任务调度是以串行方式进行，每一个环节都有赖于前一个环节的输出。<strong>但对计算图的训练是多轮迭代的过程，多轮训练之间的三个环节可以用同步与异步两种机制来进行调度执行。</strong>（其实就相当于流水线）</p><ul><li><strong>同步</strong>：顺序执行任务，当前任务执行完后会等待后续任务执行情况，任务之间需要等待、协调运行；</li><li><strong>异步</strong>：当前任务完成后，不需要等待后续任务的执行情况，可继续执行当前任务下一轮迭代。</li></ul><p>以同步机制来执行计算图训练时，每一轮迭代中，数据载入后进行数据预处理操作，然后进行训练。每一个环节执行完当前迭代中的任务后，会一直等待后续环节的处理，直至计算图完成一次迭代训练更新参数值后，才会进行下一轮迭代的数据载入、数据预处理以及网络训练。也就是说，<strong>当进行数据载入时，数据预处理、模型训练处于等待的状态</strong>；<br><img src="/img/pics/computional_graph/synchronous.png" alt="syncharonous"></p><p>以异步机制来执行计算图训练时，在迭代训练中，当数据通道载入数据后交给后续的数据预处理环节后，不需要等待计算图训练迭代完成，直接读取下一批次的数据。异步机制的引入减少了数据载入、数据预处理、网络训练三个环节的空闲等待时间，能够大幅度缩短迭代训练的整体时间，提高任务执行效率。<br><img src="/img/pics/computional_graph/asynchaonus.png" alt="asynchronous"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算图，PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合作博弈论</title>
    <link href="/2025/10/03/cooperative_game_theory/"/>
    <url>/2025/10/03/cooperative_game_theory/</url>
    
    <content type="html"><![CDATA[<h1>合作博弈论</h1><h2 id="定义">定义</h2><p>合作博弈论（英语：<strong>cooperative game theory</strong>）是博弈论中的一种理论，又称<strong>正和博弈</strong>。是指一些参与者以形成联盟、互相合作的方式所进行的博弈。这样一来博弈活动就变成了不同集团之间的对抗。</p><p>在合作博弈中，参与者未必会做出合作行为，会有一个来自外部的机构用不同方式(例如合约)惩罚非合作者。合作博弈的相反是非合作博弈，指的是参与者不可能形成联盟或任何合作机制都必须为自我履约契约（例如，透过置信威胁的方式）。</p><p>合作博弈通常是借由分析合作博弈的理论框架而得，试图想要预测会如何形成合作联盟、如何采取联合的行动以及合作所导致的成果。合作博弈和传统非合作博弈的研究方向相反，非合作博弈试图预测的是个人在博弈中的行动与成果，并分析<a href="">纳什方程式</a>。</p><h2 id="概念">概念</h2><ul><li><p><strong>合作：</strong><br>玩家可以通过协商、协议或结成联盟（coalition）来实现比单独行动更大的收益。合作博弈论研究这些联盟的形成和稳定性。</p></li><li><p><strong>特征函数：</strong><br>表示每个联盟能够获得的总收益。若玩家集合为  $N$ ，联盟  $S \subseteq N$  的收益用  $v(S)$  表示，其中  $v$  是特征函数。</p></li><li><p><strong>可转移效用（Transferable Utility, TU）：</strong><br>假设收益可以在玩家之间自由分配。若收益不可转移，则称为非可转移效用博弈（Non-Transferable Utility, NTU）。</p></li></ul><h2 id="分析的问题">分析的问题</h2><ol><li><p>收益分配：<br>核心问题是如何在联盟内部公平分配收益。主要的分配方案包括：<br>•Shapley值（Shapley Value）：基于每个玩家对不同联盟的边际贡献，计算出公平的收益分配。<br>•核（Core）：所有联盟都无力通过自我行动获得更大收益的分配方案集合，反映稳定性。<br>•凯利指数（Banzhaf Index）：一种考虑玩家影响力的分配方法。</p></li><li><p>联盟稳定性：<br>关注联盟的稳定性，即现有分配是否能防止玩家脱离联盟。稳定性通常由核来表征。</p></li><li><p>成本分摊：<br>对于某些共享成本的问题，如基础设施建设或联合采购，合作博弈论提供了一种公平的分摊方式</p></li></ol><h2 id="问题重述">问题重述</h2><p><strong>定义：</strong></p><p><strong>合作</strong>表示为三元组$(N,v)$,其中$N$是玩家集合，$v : 2^N \rightarrow \mathbb{R}$表示所有可能的合作组合$S$的收益函数。</p><h3 id="超可加性-Superadditive">超可加性(Superadditive)</h3><blockquote><p>对于博弈$G=(N,v)$若对任何$S,T \subseteq N$，$S \cap T = \emptyset$，都有$v(S \cup &gt;T )  \geq v(S)+v(T)$,则称该博弈是超可加的。</p></blockquote><p>超可加性描述的是合作比单独行动更有利，大联盟比小联盟收益更高。</p><h3 id="需要解决的问题">需要解决的问题</h3><p>1.如何构建联盟<br>2.如何分配收益</p><ul><li><p>对于问题1，我们需要考虑联盟的稳定性，即是否存在一个分配方案，使得所有玩家都不愿意离开联盟。这个问题可以通过核（Core）来解决。</p></li><li><p>对于问题2，我们需要考虑如何公平地分配收益。这个问题可以通过Shapley值来解决。</p></li></ul><h3 id="shapley-Value（夏普利值）">shapley Value（夏普利值）</h3><ul><li><p>基于每个玩家对合作的边际贡献计算，每个玩家的分配与其对整体收益的贡献成正比。<br>$$\phi_i(v) = \sum_{S \subseteq N \setminus {i}} \frac{|S|!(n - |S| - 1)!}{n!} \cdot [v(S \cup {i}) - v(S)]$$</p></li><li><p>$v(S)$ ：子集  S  的收益。</p></li><li><p>$|S|$：集合  S  中的玩家数量。</p></li><li><p>$(|N|-|S|-1)!$表示加入玩家 i 后，这期间加入的成员有多少种排列方式。</p></li></ul><p>这个公式的意义是，对于每个玩家 i，我们考虑所有不包含 i 的子集 $S$，计算 $S$ 和 $S∪{i}$ 的收益差值，然后对所有子集 S 的差值求和，最后乘以一个系数。</p><p>举个具体的例子，例如说我们有三个玩家 {A,B,C}，，他们之间合作带来的收益为：</p><ul><li>{A} = {b} = {c} = 0</li><li>{A,b} = {A,c} = 3</li><li>{b,c} = 2</li><li>{A,b,c} = 6</li></ul><p>那么我们可以计算出每个玩家的 Shapley 值，对于玩家 A，我们可以列出总共6种排列组合：<br>1.()-&gt;(A)-&gt;(A,b)-&gt;(A,b,c)<br>2.()-&gt;(A)-&gt;(A,c)-&gt;(A,b,c)<br>3.()-&gt;(b)-&gt;(A,b)-&gt;(A,b,c)<br>4.()-&gt;(b)-&gt;(b,c)-&gt;(A,b,c)<br>5.()-&gt;©-&gt;(A,c)-&gt;(A,b,c)<br>6.()-&gt;©-&gt;(b,c)-&gt;(A,b,c)</p><p>对于每种排列组合，我们可以计算出 A 的边际贡献，然后求和，最后乘以系数，就是 A 的 Shapley 值.即 $\phi_A(v) = \frac{1}{6}[(0)+(0)+(3-0)+(3-0)+(6-2)+(6-2)] = 7/3$</p><p><strong>原则：</strong></p><ul><li><p>对称性：如果两个玩家对于合作的边际贡献相同，那么他们的分配应该相同。即$\phi_i(N,v) = \phi_j(N,v)$。</p></li><li><p>零和(dummy player)：如果一个玩家对于合作没有贡献，那么他的分配应该为0。即$\phi_i(N,v) = 0$。</p></li><li><p>可加性(additivity)：如果博弈分为两部分分别博弈，那么每个玩家的分配应该是两个博弈的分配之和。即$\phi_i(N,v_1+v_2) = \phi_i(N,v_1) + \phi_i(N,v_2)$。可加性实际上是在说若进行两项互不影响的博弈，则它们的分配也应当互不影响。</p></li></ul><p><strong>满足三条原则的合作博弈，shaapley value 是唯一的。</strong></p><h3 id="核（Core）">核（Core）</h3><p><strong>定义</strong></p><blockquote><p>博弈$G=(N,v)$的核是指一个分配方案，使得所有玩家都不愿意离开联盟。即存在一个分配向量$\mathbf{x}$，使得$forall S \subseteq N, \sum_{i \in S} x_i \geq v(S)$。则称$x$是核心分配。</p></blockquote><p>核心分配的意义是，如果一个分配方案是核心分配，那么所有玩家都不愿意离开联盟，因为他们无法通过自己的行动获得更多的收益。这个概念有点类似于<a href="">纳什均衡</a>，只不过核心分配是在合作博弈中，而纳什均衡是在非合作博弈中。</p><p>那么需要考虑几个问题：</p><ul><li>核心分配是否存在？</li><li>核心分配是否唯一？</li><li>shaapley value 和核心分配的关系？即沙普利值是否一定在核中？</li></ul><p>例子，对于三个玩家 {A,B,C}，假设分配向量为$[x_A,x_B,x_C]$是分配给他们的收益，则需要满足分配收益之和为联盟的收益，即$x_A+x_B+x_C = v(N)$，同时对于任意子集$S$，$x_S \geq v(S)$。</p><p>即：<br>$$x_A+x_B+x_C = 6, x_A + x_B \geq 3, x_A + x_C \geq 3, x_B + x_C \geq 2$$</p><p>我们可以发现，沙普利值(7/3,11/6,11/6)在核中，并且核中还有其他的分配方案，比如(2,2,2)。</p><h2 id="shaapley-value-和核心分配的关系">shaapley value 和核心分配的关系</h2><p>沙普利值描述的是<strong>公平性</strong>，即每个玩家对于合作的边际贡献计算，每个玩家的分配与其对整体收益的贡献成正比。而核心分配描述的是<strong>稳定性</strong>，即存在一个分配方案，使得所有玩家都不愿意离开联盟。</p><ul><li><p>若沙普利值不在核中，但是我们取了沙普利值作为分配方案，那么此时联盟就不会稳定，这个联盟压根无法形成。</p></li><li><p>若沙普利值不在核中，我们取了核中的其他分配方案，那么此时联盟是稳定的，但是不公平，因为每个玩家的分配与其对整体收益的贡献不成正比。</p></li></ul><p>若沙普利值在核中，那么此时联盟是稳定的，且公平。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器核心原理</title>
    <link href="/2025/10/03/docker/"/>
    <url>/2025/10/03/docker/</url>
    
    <content type="html"><![CDATA[<h1>Docker核心原理</h1><p>Docker容器的本质实际上就是宿主机上的进程。</p><p><strong>进程隔离</strong>：进程隔离是指将不同的进程组分开管理，使它们相互独立，避免共享或影响对方的系统资源。进程隔离在 namespace 中起到核心作用，确保一个命名空间内的进程不会对其他命名空间的进程产生影响。实现进程隔离的目的是为了模拟不同“系统”实例的运行环境，每个命名空间内的进程都可以认为自己在独立的系统中。</p><p>如何实现Docker下的资源隔离？为了在分布式的环境下进行通信和定位，容器必然要有独立的IP、端口、路由等，自然就联想到了<strong>网络的隔离</strong>。同时，容器还需要一个<strong>独立的主机名</strong>以便在网络中标识自己。有了网络，自然离不开通信，也就想到了<strong>进程间通信需要隔离</strong>。开发者可能也已经想到了权限的问题，对用户和用户组的隔离就实现了<strong>用户权限的隔离</strong>。最后，运行在容器中的应用需要有进程号（PID），自然也需要与宿主机中的<strong>PID进行隔离</strong>。由此，基本上完成了一个容器所需要做的6项隔离，Linux内核中提供了这6种namespace隔离的系统调用</p><p><img src="/img/pics/docker/namespace.png" alt="namespace"></p><p>linux内核实现的namespcace，在同一个namespace下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，仿佛自己置身于一个独立的系统环境中，以达到独立和隔离的目的。<strong>实际上，这就是docker实现的基本原理</strong></p><h2 id="linux-namespace的API">linux namespace的API</h2><p>Linux namespace API 提供了几种系统调用接口，用于创建和管理命名空间。主要包括 clone()、unshare()、和 setns() 这三个系统调用，每个调用都用于特定的 namespace 管理操作。</p><ul><li>clone()<br>clone() 系统调用用于创建新进程，并可以指定进程应被加入到新命名空间或现有命名空间中。通过传递不同的标志，clone() 可以创建独立的命名空间，从而实现资源隔离。</li></ul><p>clone()实际上是Linux系统调用fork()的一种更通用的实现方式，它可以通过flags来控制使用多少功能。一共有20多种CLONE_*的flag（标志位）参数用来控制clone进程的方方面面（如是否与父进程共享虚拟内存等.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fn)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *<span class="hljs-built_in">stack</span>, <span class="hljs-type">int</span> flags, <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">•fn：指定子进程创建后执行的函数。<br>•stack：指向子进程栈的指针。<br>•flags：指定新进程要加入的命名空间类型，可以是以下几个标志之一或多个组合：<br>    •CLONE_NEWPID：创建新的 PID 命名空间。<br>    •CLONE_NEWNS：创建新的挂载命名空间。<br>    •CLONE_NEWNET：创建新的网络命名空间。<br>    •CLONE_NEWUTS：创建新的 UTS 命名空间。<br>    •CLONE_NEWIPC：创建新的 IPC 命名空间。<br>    •CLONE_NEWUSER：创建新的用户命名空间。<br>•arg：传递给 fn 函数的参数。<br></code></pre></td></tr></table></figure><ul><li>unshare()</li></ul><p>unshare() 用于将当前进程与某些资源隔离开来，创建新的命名空间并将当前进程加入到新的命名空间中。这样可以在已有的进程中动态创建独立的命名空间，而无需创建新进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">unshare</span><span class="hljs-params">(<span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><p>flags：指定要创建的命名空间类型，与 clone() 中的命名空间标志类似。</p><ul><li>setns()<br>setns() 系统调用允许一个进程附加到已经存在的命名空间中。通过 setns()，可以实现多进程共享同一个命名空间，或在不同的命名空间之间切换进程的资源视图。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">setns</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> nstype)</span>;<br></code></pre></td></tr></table></figure><p>fd：指向要加入的命名空间的文件描述符（通常是 /proc/[pid]/ns/ 目录下的文件）。<br>nstype：指定要加入的命名空间类型，例如 CLONE_NEWNET、CLONE_NEWNS 等。</p><p>使用 <code>setns()</code> 可以让一个进程进入到另一个进程的命名空间，适用于管理工具、监控应用等需要跨命名空间操作的场景。在Docker中，使用<code>docker exec</code>命令在已经运行着的容器中执行一个新的命令，就需要用到该方法。通过<code>setns()</code>系统调用，进程从原先的namespace加入某个已经存在的namespace，使用方法如下。通常为了不影响进程的调用者，也为了使新加入的pid namespace生效，会在<code>setns()</code>函数执行后使用<code>clone()</code>创建子进程继续执行命令，让原先的进程结束运行。</p><ul><li>/proc/[pid]/ns文件<br>从3.8版本的内核开始，用户就可以在/proc/[pid]/ns文件下看到指向不同namespace号的文件，形如[4026531839]者即为namespace号。<br><img src="/img/pics/docker/proc.png" alt="proc"></li></ul><p>如果两个进程指向的namespace编号相同，就说明它们在同一个namespace下，否则便在不同namespace里<br>面。<code>/proc/[pid]/ns</code>里设置这些link的的另外一个作用是，一旦上述link文件被打开，只要打开的文件描述符（fd）存在，那么就算该namespace下的所有进程都已经结束，这个namespace也会一直存在，后续进程也可以再加入进来。在Docker中，通过文件描述符定位和加入一个存在的namespace是最基本的方式。</p><h3 id="UTS-namespace">UTS namespace</h3><p>UTS（UNIX Time-sharing System）namespace提供了主机名和域名的隔离，这样每个Docker容器就可以拥有独立的主机名和域名了，在网络上可以被视作一个独立的节点，而非宿主机上的一个进程。Docker中，每个镜像基本都以自身所提供的服务名称来命名镜像的hostname，且不会对宿主机产生任何影响，其原理就是利用了UTS namespace。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (1024 * 1024)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> child_stack[STACK_SIZE];<span class="hljs-type">char</span>* <span class="hljs-type">const</span> child_args[] = &#123;<br>    <span class="hljs-string">&quot;/bin/bash&quot;</span>,<br>    <span class="hljs-literal">NULL</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">child_main</span><span class="hljs-params">(<span class="hljs-type">void</span>* args)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在子进程中!\n&quot;</span>);<br>    execv(child_args[<span class="hljs-number">0</span>], child_args);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序开始: \n&quot;</span>);<br>    <span class="hljs-type">int</span> child_pid = clone(child_main, child_stack +STACK_SIZE, SIGCHLD, <span class="hljs-literal">NULL</span>);<br>    waitpid(child_pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已退出\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行该程序可以看到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@<span class="hljs-built_in">local</span>:~# gcc -Wall uts.c -o uts.o &amp;&amp; ./uts.o 程序开始:<br>在子进程中!<br>root@<span class="hljs-built_in">local</span>:~# <span class="hljs-built_in">exit</span><br><span class="hljs-built_in">exit</span><br>已退出<br>root@<span class="hljs-built_in">local</span>:~#<br></code></pre></td></tr></table></figure><p>接下来修改代码加入uts隔离。运行代码需要root权限，以防止普通用户任意修改系统主机名导致set-user-ID相关的应用运行出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//[...]</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">child_main</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在子进程中!\n&quot;</span>);<br>    sethostname(<span class="hljs-string">&quot;NewNamespace&quot;</span>, <span class="hljs-number">12</span>);<br>    execv(child_args[<span class="hljs-number">0</span>], child_args);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//[...]</span><br><span class="hljs-type">int</span> child_pid = clone(child_main, child_stack+STACK_SIZE,    CLONE_NEWUTS | SIGCHLD, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//[...]</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>再次运行，可以看到namespace已经发生变化了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@<span class="hljs-built_in">local</span>:~# gcc -Wall namespace.c -o main.o &amp;&amp; ./main.o 程序开始:<br>在子进程中!<br>root@NewNamespace:~# <span class="hljs-built_in">exit</span><br><span class="hljs-built_in">exit</span><br>已退出<br>root@<span class="hljs-built_in">local</span>:~#  &lt;- 回到原来的hostname<br></code></pre></td></tr></table></figure><h3 id="IPC-namespace">IPC namespace</h3><p>进程间通信（Inter-Process Communication，IPC）涉及的IPC资源包括常见的信号量、消息队列和共享内存。申请IPC资源就申请了一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，不同IPC namespace下的进程则互相不可见。</p><p>IPC namespace在实现代码上与UTS namespace相似，只是标识位有所变化，需要加上CLONE_NEWIPC参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//[...]</span><br><span class="hljs-type">int</span> child_pid = clone(child_main, child_stack+STACK_SIZE,           CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//[...]</span><br></code></pre></td></tr></table></figure><p>目前使用IPC namespace机制的系统不多，其中比较有名的有PostgreSQL。Docker当前也使用IPC namespace实现了容器与宿主机、容器与容器之间的IPC隔离。</p><h3 id="PID-namespace">PID namespace</h3><p>PID namespace隔离非常实用，它对进程PID重新标号，<strong>即两个不同namespace下的进程可以有相同的PID</strong>。每个PID namespace都有自己的计数程序。内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的，被称为root namespace。它创建的新PID namespace被称为child namespace（树的子节点），而原先的PID namespace就是新创建的PID namespace的parentnamespace（树的父节点）。通过这种方式，不同的PIDnamespaces会形成一个层级体系。所属的父节点可以看到子节点中的进程，并可以通过信号等方式对子节点中的进程产生影响。反过来，子节点却不能看到父节点PID namespace中的任何内容。</p><p>因此：</p><ul><li>每个PID namespace中的第一个进程“PID 1”，都会像传统Linux中的init进程一样拥有特权，起特殊作用。</li><li>一个namespace中的进程，不可能通过kill或ptrace影响父节点或者兄弟节点中的进程，因为其他节点的PID在这个namespace中没有任何意义。</li><li>如果你在新的PID namespace中重新挂载/proc文件系统，会发现其下只显示同属一个PID namespace中的其他进程。</li><li>在root namespace中可以看到所有的进程，并且递归包含所有子节点中的进程。</li></ul><blockquote><p>一种在外部监控Docker中运行程序的方法：就是监控Docker daemon所在的PID namespace下的所有进程及其&gt; 子进程，再进行筛选即可。</p></blockquote><h4 id="PID-namespace中的init进程">PID namespace中的init进程</h4><p>在传统的Unix系统中，PID为1的进程是init，地位非常特殊。它作为所有进程的父进程，维护一张进程表，不断检查进程的状态，一旦有某个子进程因为父进程错误成为了“孤儿”进程，init就会负责收养这个子进程并最终回收资源，结束进程。所以在要实现的容器中，启动的第一个进程也需要实现类似init的功能，维护所有后续启动进程的运行状态。</p><p>当系统中存在树状嵌套结构的PID namespace时，若某个子进程成为孤儿进程，收养该子进程的责任就交给了该子进程所属的PID namespace中的init进程。PID namespace维护这样一个树状结构，有利于系统的资源监控与回收。因此，如果确实需要在一个Docker容器中运行多个进程，最先启动的命令进程应该是具有资源监控与回收等管理能力的，如bash。</p><h4 id="信号与init进程">信号与init进程</h4><p>内核还为PID namespace中的init进程赋予了其他特权——信号屏蔽。如果init中没有编写处理某个信号的代码逻辑，那么与init在同一个PID namespace下的进程（即使有超级权限）发送给它的该信号都会被屏蔽。这个功能的主要作用是防止init进程被误杀。</p><p>那么，父节点PID namespace中的进程发送同样的信号给子节点中的init进程，这会被忽略吗？父节点中的进程发送的信号，如果不是SIGKILL（销毁进程）或SIGSTOP（暂停进程）也会被忽略。但如果发送SIGKILL或SIGSTOP，子节点的init会强制执行（无法通过代码捕捉进行特殊处理），也即是说父节点中的进程有权终止子节点中的进程。</p><p><strong>一旦init进程被销毁，同一PID namespace中的其他进程也随之接收到SIGKILL信号而被销毁</strong> 。理论上，该PID namespace也不复存在了。但是如果/proc/[pid]/ns/pid 处于被挂载或者打开状态，namespace就会被保留下来。然而，保留下来的namespace无法通过setns()或者fork()创建进程，所以实际上并没有什么作用。</p><p>当一个容器内存在多个进程时，容器内的init进程可以对信号进行捕获，当SIGTERM或SIGINT等信号到来时，对其子进程做信息保存、资源回收等处理工作。在Docker daemon的源码中也可以看到类似的处理方式，当结束信号来临时，结束容器进程并回收相应资源。</p><p>创建其他namespace时unshare()和setns()会直接进入新的namespace，而唯独PID namespace例外。因为调用getpid()函数得到的PID是根据调用者所在的PID namespace而决定返回哪个PID，进入新的PID namespace会导致PID产生变化。而对用户态的程序和库函数来说，它们都认为进程的PID是一个常量，PID的变化会引起这些进程崩溃。</p><p>换句话说，一旦程序进程创建以后，那么它的PID namespace 的关系就确定下来了，进程不会变更它们对应的PID<br>namespace。在Docker中，docker exec会使用setns()函数加入已经存在的命名空间，但是最终还是会调用clone()函数，原因就在于此。</p><h3 id="mount-namespace">mount namespace</h3><p>mount namespace通过隔离文件系统挂载点对隔离文件系统提供支持，它是历史上第一个Linux namespace，所以标识位比较特殊，就是CLONE_NEWNS。隔离后，不同mount namespace中的文件结构发生变化也互不影响。可以通过<code>/proc/[pid]/mounts</code>查看到所有挂载在当前namespace中的文件系统，还可以通过<code>/proc/[pid]/mountstats</code>看到mount namespace中文件设备的统计信息，包括挂载文件的名字、文件系统类型、挂载位置等。</p><p>进程在创建mount namespace时，会把当前的文件结构复制给新的namespace。新namespace中的所有mount操作都只影响自身的文件系统，对外界不会产生任何影响。这种做法非常严格地实现了隔离，但对某些情况可能并不适用。</p><blockquote><p>比如父节点namespace中的进程挂载了一张CD-ROM，这时子节点namespace复制的目录结构是无法自动挂载上这&gt;&gt;张CD-ROM的，因为这种操作会影响到父节点的文件系统。</p></blockquote><p>挂载传播（mount propagation）解决了这个问题，挂载传播定义了挂载对象（mount object）之间的关系，这样的关系包括<strong>共享关系</strong>和<strong>从属关系</strong>，系统用这些关系决定任何挂载对象中的挂载事件如何传播到其他挂载对象。</p><ul><li><strong>共享关系</strong>: 如果两个挂载对象具有共享关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，反之亦然。</li><li><strong>从属关系</strong>: 如果两个挂载对象形成从属关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，但是反之不行；在这种关系中，从属对象是事件的接收者。</li></ul><p>传播事件的挂载对象称为<strong>共享挂载</strong>；接收传播事件的挂载对象称为<strong>从属挂载</strong>；同时兼有前述两者特征的挂载对象称为<strong>共享/从属挂载</strong>；既不传播也不接收传播事件的挂载对象称为<strong>私有挂载</strong>；另一种特殊的挂载对象称为<strong>不可绑定的挂载</strong>，它们与私有挂载相似，但是不允许执行绑定挂载，即创建mount namespace时这块文件对象不可被复制。</p><p><img src="/img/pics/docker/mount.png" alt="mount"></p><h3 id="network-namespace">network namespace</h3><p>当我们了解完各类namespace，兴致勃勃地构建出一个容器，并在容器中启动一个Apache进程时，却出现了“80端口已被占用”的错误，原来主机上已经运行了一个Apache进程，这时就需要借助network namespace技术进行网络隔离。</p><p>network namespace主要提供了关于网络资源的隔离，包括网络设备、IPv4和IPv6协议栈、IP路由表、防火墙、<code>/proc/net</code>目录、<code>/sys/class/net</code>目录、套接字（socket）等。<strong>一个物理的网络设备最多存在于一个network namespace中</strong>，</p><blockquote><p>可以通过创建veth pair（虚拟网络设备对：有两端，类似管道，如果数据从一端传入另一端也能接收到，反之亦然）在不同的network namespace 间创建通道，以达到通信目的。</p></blockquote><p>一般情况下，物理网络设备都分配在最初的root namespace（表示系统默认的namespace）中。但是如果有多块物理网卡，也可以把其中一块或多块分配给新创建的network namespace。</p><p>:warning: 需要注意的是，当新创建的network namespace被释放时（所有内部的进程都终止并且namespace文件没有被挂载或打开），<strong>在这个namespace 中的物理网卡会返回到root namespace，而非创建该进程的父进程所在的network namespace。</strong></p><p>当说到network namespace时，指的未必是真正的网络隔离，而是把网络独立出来，给外部用户一种透明的感觉，仿佛在与一个独立网络实体进行通信。</p><p>为了达到该目的，容器的经典做法就是创建一个veth pair（虚拟以太网对），一端放置在新的namespace中，通常命名为eth0，一端放在原先的namespace中连接物理网络设备，再通过把多个设备接入网桥或者进行路由转发，来实现通信的目的。在建立起veth pair之前，新旧namespace该如何通信呢？答案是pipe（管道）。</p><blockquote><p>以Docker daemon启动容器的过程为例，假设容器内初始化的进程称为init。Docker daemon在宿主机上负责创建这个veth pair，把一端绑定到docker0网桥上，另一端接入新建的network namespace进程中。这个过程执行期间，Docker daemon和init就通过pipe进行通信。具体来说，就是在Docker daemon完成veth pair的创建之前，init在管道的另一端循环等待，直到管道另一端传来Docker daemon关于veth设备的信息，并关闭管道。init才结束等待的过程，并把它的“eth0”启动起来。</p></blockquote><p><img src="/img/pics/docker/veth.png" alt="veth pair in docker"></p><h3 id="user-namespace">user namespace</h3><p>user namespace主要隔离了安全相关的标识符（identifier）和属性（attribute），包括用户ID、用户组ID、root目录、key（指密钥）以及特殊权限。通俗地讲，一个普通用户的进程通过clone()创建的新进程在新user namespace中可以拥有不同的用户和用户组。这意味着一个进程在容器外属于一个没有特权的普通用户，但是它创建的容器进程却属于拥有所有权限的超级用户，这个技术为容器提供了极大的自由。</p><p>user namespace实际上并不算完全成熟，很多发行版担心安全问题，在编译内核的时候并未开启USER_NS。Docker在1.10 版本中对user namespace进行了支持。只要用户在启动Docker daemon的时候指定了–userns-remap，那么当用户运行容器时，容器内部的root用户并不等于宿主机内的root用户，而是映射到宿主上的普通用户。</p><ul><li>user namespace被创建后，第一个进程被赋予了该namespace 中的全部权限，这样该init进程就可以完成所有必要的初始化工作，而不会因权限不足出现错误。</li><li>从namespace内部观察到的UID和GID已经与外部不同了，表示尚未与外部namespace用户映射。此时需要对user namespace内部的这个初始user和它外部namespace 的某个用户建立映射，这样可以保证当涉及一些对外部namespace的操作时，系统可以检验其权限（比如发送一个信号量或操作某个文件）。同样用户组也要建立映射。</li><li>用户在新namespace中有全部权限，但它在创建它的父namespace中不含任何权限，就算调用和创建它的进程有全部权限也是如此。因此哪怕是root用户调用了clone()在user namespace中创建出的新用户，在外部也没有任何权限。</li><li>最后，user namespace的创建其实是一个层层嵌套的树状结构。最上层的根节点就是root namespace，新创建的每个user namespace都有一个父节点user namespace，以及零个或多个子节点user namespace，这一点与PID namespace非常相似。</li></ul><p><img src="/img/pics/docker/user.png" alt="user namespace"></p><p>进行用户绑定，可以通过在<code>/proc/[pid]/uid_map`` 和</code>/proc/[pid]/gid_map```两个文件中写入对应的绑定信息就可以实现这一点，格式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ID-inside-ns   ID-outside-ns   length<br></code></pre></td></tr></table></figure><p>如果要把user namespace与其他namespace混合使用，那么依旧需要root权限。解决方案是先以普通用户身份创建user namespace，然后在新建的namespace中作为root，在clone()进程加入其他类型的namespace隔离。</p><p>Docker不仅使用了user namespace，还使用了在user namespace中涉及的Capabilities机制。Linux把原来和超级用户相关的高级权限划分为不同的单元，称为Capability。这样管理员就可以独立对特定的Capability进行使用或禁止。Docker同时使用user namespace和Capability，这在很大程度上加强了容器的安全性。</p><h2 id="cgroups资源限制">cgroups资源限制</h2><p>cgroups不仅可以限制被namespace隔离起来的资源，还可以为资源设置权重、计算使用量、操控任务（进程或线程）启停等。</p><h3 id="cgroups介绍">cgroups介绍</h3><p>cgroups是Linux内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合（或分隔）到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。</p><p>cgroups可以限制、记录任务组所使用的物理资源（包括CPU、Memory、IO等），为容器实现虚拟化提供了基本保证，是构建Docker等一系列虚拟化管理工具的基石。</p><p><strong>cgroups具有的特点</strong>：</p><ul><li>cgroups的API以一个伪文件系统的方式实现，用户态的程序可以通过文件操作实现cgroups的组织管理。</li><li>cgroups的组织管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroup，从而实现资源再分配和管理。</li><li>所有资源管理的功能都以子系统的方式实现，接口统一。</li><li>子任务创建之初与其父任务处于同一个cgroups的控制组。</li></ul><h3 id="cgroups作用">cgroups作用</h3><p>实现cgroups的主要目的是为不同用户层面的资源管理，提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化，cgroups提供了以下四大功能9。</p><ul><li><strong>资源限制</strong>：cgroups可以对任务使用的资源总额进行限制。如设定应用运行时使用内存的上限，一旦超过这个配额就发出OOM（Out of Memory）提示。</li><li><strong>优先级分配</strong>：通过分配的CPU时间片数量及磁盘IO带宽大小，实际上就相当于控制了任务运行的优先级。</li><li><strong>资源统计</strong>：cgroups可以统计系统的资源使用量，如CPU使用时长、内存用量等，这个功能非常适用于计费。</li><li><strong>任务控制</strong>：cgroups可以对任务执行挂起、恢复等操作。</li></ul><h3 id="cgroups术语表">cgroups术语表</h3><ul><li><strong>task（任务）</strong>：在cgroups的术语中，任务表示系统的一个进程或线程。</li><li><strong>cgroup（控制组）</strong>：cgroups中的资源控制都以cgroup为单位实现。cgroup表示按某种资源控制标准划分而成的任务组，包含一个或多个子系统。一个任务可以加入某个cgroup，也可以从某个cgroup迁移到另外一个cgroup。</li><li><strong>subsystem（子系统）</strong>：cgroups中的子系统就是一个资源调度控制器。比如CPU子系统可以控制CPU时间分配，内存子系统可以限制cgroup内存使用量。</li><li><strong>hierarchy（层级）</strong>：层级由一系列cgroup以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。层级中的cgroup节点可以包含零或多个子节点，子节点继承父节点挂载的子系统。整个操作系统可以有多个层级。</li></ul><h3 id="组织结构与基本规则">组织结构与基本规则</h3><p>系统中的多个cgroup构成树状结构，子节点从父节点继承属性。系统中的多个cgroup构成的层级并非单根结构，可以允许存在多个。</p><p>如果任务模型是由init作为根节点构成的一棵树，那么系统中的多个cgroup则是由多个层级构成的森林。这样做的目的很好理解，如果只有一个层级，那么所有的任务都将被迫绑定其上的所有子系统，这会给某些任务造成不必要的限制。<strong>在Docker中，每个子系统独自构成一个层级，这样做非常易于管理。</strong></p><p><strong>规则：</strong></p><ul><li><p>规则1:同一个层级可以附加一个或多个子系统。</p></li><li><p>规则2:一个子系统可以附加到多个层级，当且仅当目标层级只有唯一一个子系统时。</p></li><li><p>规则3:系统每次新建一个层级时，该系统上的所有任务默认加入这个新建层级的初始化cgroup，这个cgroup也被称为root cgroup。对于创建的每个层级，任务只能存在于其中一个cgroup中，即一个任务不能存在于同一个层级的不同cgroup中，但一个任务可以存在于不同层级中的多个cgroup中。</p></li><li><p>规则4:任务在fork/clone自身时创建的子任务默认与原任务在同一个cgroup中，但是子任务允许被移动到不同的cgroup中。即fork/clone完成后，父子任务间在cgroup方面是互不影响的。</p></li></ul><h3 id="子系统">子系统</h3><p>子系统实际上就是cgroups的资源控制系统，每种子系统独立地控制一种资源，目前Docker使用如下9种子系统：<br><strong>blkio</strong>：可以为块设备设定输入/输出限制，比如物理驱动设备（包括磁盘、固态硬盘、USB等）。<br><strong>cpu</strong>：使用调度程序控制任务对CPU的使用。<br><strong>cpuacct</strong>：自动生成cgroup中任务对CPU资源使用情况的报告。<br><strong>cpuset</strong>：可以为cgroup中的任务分配独立的CPU（此处针对多处理器系统）和内存。<br><strong>devices</strong>：可以开启或关闭cgroup中任务对设备的访问。<br><strong>freezer</strong>：可以挂起或恢复cgroup中的任务。<br><strong>memory</strong>：可以设定cgroup中任务对内存使用量的限定，并且自动生成这些任务对内存资源使用情况的报告。<br><strong>perf_event</strong>：使用后使cgroup中的任务可以进行统一的性能测试。<br><strong>net_cls</strong>：Docker没有直接使用它，它通过使用等级识别符（classid）标记网络数据包，从而允许Linux流量控制程序（Traffic Controller，TC）识别从具体cgroup中生成的数据包。</p><p>在Docker的实现中，Docker daemon会在单独挂载了每一个子系统的控制组目录（比如<code>/sys/fs/ cgroup/cpu</code>）下创建一个名为docker的控制组，然后在docker控制组里面，再为每个容器创建一个以容器ID为名称的容器控制组，这个容器里的所有进程的进程号都会写到该控制组tasks中，并且在控制文件（比如cpu.cfs_quota_us）中写入预设的限制参数值。</p><h3 id="cgroups实现方式和工作原理">cgroups实现方式和工作原理</h3><p>cgroups的实现本质上是给任务挂上钩子，当任务运行的过程中涉及某种资源时，就会触发钩子上所附带的子系统进行检测，根据资源类别的不同，使用对应的技术进行资源限制和优先级分配。</p><h2 id="Docker架构概览">Docker架构概览</h2><p>Docker使用了传统的<code>client-server</code>架构模式。用户通过Docker client与Docker daemon建立通信，并将请求发送给后者。而Docker的后端是松耦合结构，不同模块各司其职，有机组合，完成用户的请求。<br><img src="/img/pics/docker/docker_arc.png" alt="Docker架构"></p><p>Docker daemon是Docker架构中的主要用户接口。首先，它提供了API Server用于接收来自Docker client的请求，其后根据不同的请求分发给Docker daemon的不同模块执行相应的工作，其中对容器运行时、volume、镜像以及网络方面的具体实现已经放在daemon以外的模块或项目中。</p><h3 id="Docker-daemon">Docker daemon</h3><p>Docker daemon是Docker最核心的后台进程，它负责响应来自Docker client的请求，然后将这些请求翻译成系统调用完成容器管理操作。该进程会在后台启动一个API Server，负责接收由Docker client发送的请求；接收到的请求将通过Docker daemon分发调度，再由具体的函数来执行请求。</p><p><strong>Docker client</strong>是一个泛称，用来向Docker daemon发起请求，执行相应的容器管理操作。它既可以是命令行工具docker，也可以是任何遵循了Docker API的客户端。</p><h3 id="镜像管理">镜像管理</h3><p>Docker通过distribution、registry、layer、image、reference等模块实现<br>了Docker镜像的管理，这些模块统称为镜像管理（imagemanagement）。</p><ul><li>distribution负责与Docker registry交互，上传下载镜像以及存储与v2 registry有关的元数据。</li><li>registry模块负责与Docker registry有关的身份验证、镜像查找、镜像验证以及管理registry mirror等交互操作。</li><li>image模块负责与镜像元数据有关的存储、查找，镜像层的索引、查找以及镜像tar包有关的导入、导出等操作。</li><li>reference负责存储本地所有镜像的repository和tag名，并维护与镜像ID之间的映射关系。</li><li>layer模块负责与镜像层和容器层元数据有关的增删查改，并负责将镜像层的增删查改操作映射到实际存储镜像层文件系统的graphdriver模块。</li></ul><p>Docker daemon负责将用户请求转译成系统调用，进而创建和管理容器。而在具体实现过程中，为了将这些系统调用抽象成为统一的操作接口方便调用者使用，Docker把这些操作分成了容器执行驱动、volume存储驱动、镜像存储驱动3种，分别对应<strong>execdriver</strong>、<strong>volumedriver</strong>和<strong>graphdriver</strong>。</p><h3 id="client与daemon">client与daemon</h3><p><strong>client模式</strong>：<br>docker命令对应的源文件是<code>docker/docker.go</code>（如果不做说明，根路径是项目的根目录<br>docker/），它的使用方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker [OPTIONS] COMMAND [arg...]<br></code></pre></td></tr></table></figure><p>其中OPTIONS参数称为flag，任何时候执行一个docker命令，Docker都需要先解析这些flag，然后按照用户声明的COMMAND向指定的子命令执行对应的操作。如果子命令为daemon，Docker就会创建一个运行在宿主机的daemon<br>进程（<code>docker/daemon.go#mainDaemon</code>），即执行daemon模式。其余子命令都会执行client模式。处于client模式下的docker命令工作流程包含如下几个步骤。</p><ul><li><strong>解析flag信息</strong></li><li><strong>创建client实例</strong></li><li><strong>执行具体命令</strong></li><li><strong>执行对应的方法，发起请求</strong></li></ul><p><strong>daemon模式</strong>：<br>一旦docker进入了daemon模式，剩下的初始化和启动工作就都由Docker的<code>docker/daemon.go#CmdDaemon</code>来完成。Docker daemon通过一个server模块（<code>api/server/server.go</code>）接收来自client的请求，然后根据请求类型，交由具体的方法去执行。因此daemon首先需要启动并初始化这个server。另一方面，启动server后，Docker进程需要初始化一个daemon对象（daemon/daemon.go）来负责处理server接收到的请求。</p><p>下面是Docker daemon启动与初始化过程的详细解析。</p><ul><li><strong>API Server的配置和初始化过程</strong></li><li><strong>Daemon对象的创建与初始化过程</strong></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Docker，虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s概述</title>
    <link href="/2025/10/03/k8s/"/>
    <url>/2025/10/03/k8s/</url>
    
    <content type="html"><![CDATA[<h1>Docker云平台解读</h1><p>kubernetes是一个管理跨主机容器化应用的系统，实现了包括应用部署、高可用管理和弹性伸缩在内的一系列基础功能并封装为一套完整、简单易用的RESTful API接口。</p><h2 id="Restful-API">Restful API</h2><p>RESTful API（Representational State Transfer API）是一种设计风格的应用程序接口（API），它基于 REST 架构风格，用于在不同的系统或应用之间通过 HTTP 协议进行通信。RESTful API 是目前最流行的 API 架构风格之一，广泛应用于 Web 服务和移动应用等场景。其核心思想是通过 HTTP 协议以一种简单、无状态的方式进行系统间的通信。一个遵循 REST 架构风格的 API 被称为 RESTful API。</p><p>RESTful API 的核心组成部分包括<strong>资源（Resources）</strong>、<strong>HTTP 方法</strong>、**状态码（HTTP Status Codes）**等。下面是 RESTful API 的一些重要特点：</p><ul><li><p><strong>资源（Resources）</strong>：RESTful API 中的每个“资源”都可以通过 URI（Uniform Resource Identifier，统一资源标识符）来唯一标识。例如，/users 可能表示用户资源，/posts 可能表示博客文章资源。</p></li><li><p><strong>HTTP 方法</strong>：RESTful API 使用标准的 HTTP 方法来执行对资源的操作，常用的 HTTP 方法有：</p><ul><li>GET：用于获取资源，不会对服务器上的数据产生副作用。</li><li>POST：用于创建资源或提交数据。</li><li>PUT：用于更新现有资源的全部内容。</li><li>PATCH：用于部分更新资源。</li><li>DELETE：用于删除资源。</li></ul></li><li><p><strong>状态码（HTTP Status Codes）</strong>：RESTful API 使用 HTTP 状态码来表示请求的结果。例如：</p><ul><li>200 OK：请求成功。</li><li>201 Created：成功创建资源。</li><li>400 Bad Request：请求参数错误。</li><li>404 Not Found：资源未找到。</li><li>500 Internal Server Error：服务器内部错误。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>kubernetes,云平台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数及其应用</title>
    <link href="/2025/10/03/liner-algebra/"/>
    <url>/2025/10/03/liner-algebra/</url>
    
    <content type="html"><![CDATA[<h1>笔记</h1><p>本文是临近夏令营，简单地复习了一下线性代数方面相关的内容，果然重学了一遍才知道当初什么都没学懂！之后还会更新一些进阶的内容，希望我能记得起来。</p><h2 id="线性代数及其应用">线性代数及其应用</h2><h3 id="线性方程组">线性方程组</h3><p>线性方程式形如$a_1x_1+a_2x_2+\cdots+a_nx_n=b$的式子，其中$a_i$为系数，$x_i$为未知数，$b$为常数。</p><p>一个线性方程组则为：</p><p>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n&amp;=b_1\<br>a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n&amp;=b_2\<br>\vdots \<br>a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n&amp;=b_m<br>\end{cases}<br>$$</p><p>其中$m$为方程个数，$n$为未知数个数。</p><p>线性方程组的解只有三种情况：</p><ul><li>无解</li><li>唯一解</li><li>无穷多解</li></ul><p>注意到：<strong>一个线性方程组是相容的，指的若它有一个解或者无穷多解；而一个方程组是不相容的，指的若它无解。</strong></p><h3 id="矩阵乘法">矩阵乘法</h3><p>线性方程组可以用矩阵形式表示：</p><h1>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}<br>\end{bmatrix}<br>\begin{bmatrix}<br>x_1\<br>x_2\<br>\vdots \<br>x_n<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>b_1\<br>b_2\<br>\vdots \<br>b_m<br>\end{bmatrix}<br>$$</p><p>其中，这个线性方程组的增广矩阵形式为：</p><p>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} &amp; b_1\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} &amp; b_2\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\<br>a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} &amp; b_m<br>\end{bmatrix}<br>$$</p><p><strong>矩阵的维数指的是矩阵的行数和列数。</strong></p><h4 id="求解线性方程组">求解线性方程组</h4><p>基本方法：</p><ul><li>初等行变换<ul><li>（倍加变换）把某一行换成它本身与另一行的倍数的和。</li><li>（倍乘变换）把某一行乘以一个非零常数。</li><li>（对换变换）把某两行互换位置。</li></ul></li></ul><p><strong>如果两个矩阵是行等价的，那么其中某一个矩阵可以通过一系列初等行变换变换成另一个矩阵。</strong></p><p><strong>初等行变换是可逆的！</strong></p><pre><code class="hljs">推论：若两个线性方程组的增广矩阵是行等价的，则它们的解集相同。</code></pre><p>注意：<br>线性方程组的两个基本问题：<strong>存在和唯一性</strong></p><pre><code class="hljs">存在与唯一性定理：    线性方程组相容的充要条件是增广矩阵的最右列不是主元列，就是说增广矩阵没有形如                [ 0 ...  0  b] b!= 0的行,若线性方程组相容它的解集有两种情况：    (i)当没有自由变量时，有唯一解；    (ii)当至少有一个自由变量时，有无穷多解。</code></pre><h4 id="向量方程">向量方程</h4><p>仅含一列的矩阵称为列向量，仅含一行的矩阵称为行向量（简称向量）。</p><p>向量的加法：</p><h1>$$<br>\begin{bmatrix}<br>a_1\<br>a_2\<br>\vdots \<br>a_n<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>b_1\<br>b_2\<br>\vdots \<br>b_n<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>a_1+b_1\<br>a_2+b_2\<br>\vdots \<br>a_n+b_n<br>\end{bmatrix}<br>$$</p><p>向量的数乘（标量乘法）：</p><h1>$$<br>c\begin{bmatrix}<br>a_1\<br>a_2\<br>\vdots \<br>a_n<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>ca_1\<br>ca_2\<br>\vdots \<br>ca_n<br>\end{bmatrix}<br>$$</p><p>向量的内积：</p><h1>$$<br>\begin{bmatrix}<br>a_1\<br>a_2\<br>\vdots \<br>a_n<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>b_1\<br>b_2\<br>\vdots \<br>b_n<br>\end{bmatrix}</h1><p>\sum_{i=1}^n a_ib_i<br>$$</p><h5 id="线性组合：">线性组合：</h5><p>给定$R^n$中的向量 $\mathbf{v_1}, \mathbf{v_2}, \cdots, \mathbf{v_n}$，以及相应的系数 $c_1, c_2, \cdots, c_n$，则：</p><p>$$<br>\mathbf{y}=c_1\mathbf{v_1}+c_2\mathbf{v_2}+\cdots+c_n\mathbf{v_n}<br>$$</p><p>称为向量 $\mathbf{v_1}, \mathbf{v_2}, \cdots, \mathbf{v_n}$ 以系数 $c_1, c_2, \cdots, c_n$ 为权的的线性组合，其中 $\mathbf{y}$ 是 $R^n$ 中的一个向量。</p><h5 id="向量方程：">向量方程：</h5><p>向量方程：</p><p>$$<br>\mathbf{a_1}x_1+\mathbf{a_2}x_2+\cdots+\mathbf{a_nx_n}=\mathbf{b}<br>$$</p><p>和增广矩阵</p><p>$$<br>\begin{bmatrix}<br>\mathbf{a_1} &amp; \mathbf{a_2} &amp; \cdots &amp; \mathbf{a_n} &amp; \mathbf{b}<br>\end{bmatrix}<br>$$</p><p>的线性方程组具有相同的解集，其中$\mathbf{b}$可以看作是$\mathbf{a_1}, \mathbf{a_2}, \cdots, \mathbf{a_n}$的线性组合，当且仅当线性方程组有解。</p><p>给定$R^n$中的向量 $\mathbf{v_1}, \mathbf{v_2}, \cdots, \mathbf{v_n}$，则$\mathbf{v_1}, \mathbf{v_2}, \cdots, \mathbf{v_n}$的所有线性组合构成了$R^n$中的一个向量空间，记作$\mathcal{V}$，也可表示为$Span{\mathbf{v_1}, \mathbf{v_2}, \cdots, \mathbf{v_n}}$。<br>即形如：</p><p>$$<br>\mathbf{a_1}c_1+\mathbf{a_2}c_2+\cdots+\mathbf{a_nc_n}<br>$$</p><p>的向量的集合，其中$c_1, c_2, \cdots, c_n$为标量。</p><h4 id="线性方程Ax-b">线性方程Ax=b</h4><p>若$\mathbf{A}$是m行n列的矩阵，它的各列为$\mathbf{a_1}, \mathbf{a_2}, \cdots, \mathbf{a_n}$，$\mathbf{x}$是$R^n$中的列向量，则$\mathbf{A}$与$\mathbf{x}$的乘积就是$\mathbf{A}$的各列以$\mathbf{x}$中对应元素为权的线性组合。</p><h1>$$<br>\mathbf{A}\mathbf{x}=<br>\begin{bmatrix}<br>\mathbf{a}_1 &amp; \mathbf{a}_2 &amp; \cdots &amp; \mathbf{a}_n<br>\end{bmatrix}<br>\begin{bmatrix}<br>x_1\<br>x_2\<br>\vdots \<br>x_n<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>\mathbf{a}_1 x_1+\mathbf{a}_2 x_2+\cdots+\mathbf{a}_n x_n<br>\end{bmatrix}<br>$$</p><p>注意：<strong>当且仅当 $\mathbf{Ax}$ 中$\mathbf{A}$的列数等于$\mathbf{x}$的维数时，才有定义</strong></p><pre><code class="hljs">方程Ax=b有解当且仅当b是A的各列行向量的线性组合。</code></pre><p>性质：<br>若$\mathbf{A}$是m行n列的矩阵，$\mathbf{u}$和$\mathbf{v}$是$R^n$中的向量，$c$是标量，则：</p><ul><li>$\mathbf{A}(\mathbf{u}+\mathbf{v})=\mathbf{A}\mathbf{u}+\mathbf{A}\mathbf{v}$</li><li>$\mathbf{A}(c\mathbf{u})=c\mathbf{A}\mathbf{u}$</li></ul><h4 id="齐次线性方程组">齐次线性方程组</h4><p>齐次线性方程组：</p><p>线性方程组称为齐次的，当前仅当它可以写为：$\mathbf{A}\mathbf{x}=\mathbf{0}$的形式，其中$\mathbf{A}$是m行n列的矩阵，$\mathbf{x}$是$R^n$中的列向量，$\mathbf{0}$是$R^m$中的零向量。这样的方程组至少有一个解，即$\mathbf{x}=\mathbf{0}$。<strong>更重要的是我们需要知道它是否有非平凡解</strong></p><pre><code class="hljs">齐次线性方程组有非平凡解当且仅当方程至少含有一个自由变量。</code></pre><h5 id="参数表示的非齐次线性方程组的解">参数表示的非齐次线性方程组的解</h5><p>设方程$\mathbf{Ax}=\mathbf{b}$对某个$\mathbf{b}$是相容的，$\mathbf{p}$是一个特解，则$\mathbf{Ax}=\mathbf{b}$的解集可以表示为：<br>$\mathbf{w}=\mathbf{p}+\mathbf{v_h}$，其中$\mathbf{v_h}$是齐次方程$\mathbf{Ax}=\mathbf{0}$的任意一个解。</p><p>说明若$\mathbf{Ax}=\mathbf{b}$有解，则解集可由$\mathbf{Ax}=\mathbf{0}$的解平移向量$\mathbf{p}$得到。</p><h3 id="线性无关">线性无关</h3><p>$R^n$中一组向量${\mathbf{v_1}, \mathbf{v_2}, \cdots, \mathbf{v_n}}$线性无关，若向量方程</p><p>$$<br>x_1\mathbf{v_1}+x_2\mathbf{v_2}+\cdots+x_n\mathbf{v_n}=\mathbf{0}<br>$$</p><p>仅有平凡解。若为线性相关的，则存在不全为0的权${c_1, c_2, \cdots, c_n}$使得</p><p>$$<br>c_1\mathbf{v_1}+c_2\mathbf{v_2}+\cdots+c_n\mathbf{v_n}=\mathbf{0}<br>$$</p><h4 id="线性相关的特征">线性相关的特征</h4><p>两个或更多向量的集合$S={\mathbf{v_1}, \mathbf{v_2}, \cdots, \mathbf{v_n}}$线性相关，当且仅当$S$中至少有一个向量是其他向量的线性组合，事实上，若S线性相关，且$\mathbf{v_1}\neq\mathbf{0}$，则某个$\mathbf{v_j}(j&gt;1)$是它前面几个向量${\mathbf{v_1}, \mathbf{v_2}, \cdots, \mathbf{v_{j-1}}}$的线性组合。</p><pre><code class="hljs">定理：若一个向量组的向量个数超过每个向量元素的个数，则该向量组线性相关。定理：若向量组S里包含零向量，则S线性相关。</code></pre><h3 id="线性变换">线性变换</h3><p>变换$\mathbf{T}$是线性的，若：</p><ul><li>对$\mathbf{T}$的定义域中的一切$\mathbf{u}$和$\mathbf{v}$，都有$\mathbf{T}(\mathbf{u}+\mathbf{v})=\mathbf{T}(\mathbf{u})+\mathbf{T}(\mathbf{v})$</li><li>对一切的标量$c$和向量$\mathbf{u}$，都有$\mathbf{T}(c\mathbf{u})=c\mathbf{T}(\mathbf{u})$</li></ul><h4 id="线性变换的矩阵">线性变换的矩阵</h4><p>设$\mathbf{T}$是$R^n$到$R^m$的线性变换，$\mathbf{T}$的矩阵形式为$\mathbf{A}$，则：</p><p>$$<br>\mathbf{T}(\mathbf{x})=\mathbf{Ax}<br>$$</p><p>对一切$R^n$中的向量$\mathbf{x}$，都有$\mathbf{T}(\mathbf{x})$是$R^m$中的向量。事实上，$\mathbf{A}$是$m\times n$矩阵，它的第$i$行是$\mathbf{T}(\mathbf{e}_i)$，其中$\mathbf{e}_i$是单位矩阵$\mathbf{I}_n$中的第$i$列。<br>即：</p><p>$$<br>\mathbf{A} = \left[ \mathbf{T}(\mathbf{e}_1), \mathbf{T}(\mathbf{e}_2), \ldots, \ \mathbf{T}(\mathbf{e}_n) \right]<br>$$</p><h3 id="矩阵代数">矩阵代数</h3><p>设$A$和$B$为$m\times n$矩阵，则有如下的结果：</p><p>1、$(A^T)^T=A$，即$A^T$的转置等于$A$<br>2、$(AB)^T=B^TA^T$，即$AB$的转置等于$B^TA^T$<br>3、$(A+B)^T=A^T+B^T$，即$(A+B)$的转置等于$A^T+B^T$</p><h4 id="可逆矩阵">可逆矩阵</h4><p>设$A$为$m\times n$矩阵，如果存在非零元素的$n\times n$矩阵$B$，使得$AB=BA=I_n$，则称$A$为可逆矩阵。不可逆矩阵也称为奇异矩阵。</p><p>对于二阶矩阵$\begin{bmatrix}a &amp; b\c &amp; d \end{bmatrix}$的逆矩阵，有：</p><p>$$<br>A^{-1}=\frac{1}{ad-bc}\begin{bmatrix}<br>d &amp; -b\<br>-c &amp; a<br>\end{bmatrix}<br>$$</p><p>其中，若$ad-bc\neq 0$，则$A$为可逆矩阵；若$ad-bc=0$，则$A$为奇异矩阵。</p><p>如果一个维度为$n\times n$的矩阵$A$可逆，则对$R^n$中任一向量$\mathbf{b}$，方程$A\mathbf{x}=\mathbf{b}$的解$\mathbf{x}$也可唯一确定,解为：</p><p>$$<br>\mathbf{x}=\begin{bmatrix}<br>A^{-1}<br>\end{bmatrix}\mathbf{b}<br>$$</p><h5 id="可逆矩阵定理：">可逆矩阵定理：</h5><p>1、对于任意数$r$,有$(rA)^T=rA^T$<br>2、$(A^T)^{-1}=(A^{-1})^T$<br>3、$(AB)^{-1}=B^{-1}A^{-1}$，即$(AB)^{-1}$等于$B^{-1}A^{-1}$。</p><h4 id="初等变换与矩阵求逆">初等变换与矩阵求逆</h4><p>初等变换是指将单位矩阵进行一次初等行变换。行变换是可逆的，因此得到的初等矩阵也是可逆的，并且有初等矩阵$E$的逆是一个同类型的初等矩阵，它将矩阵$E$变换到单位阵。</p><pre><code class="hljs">定理：nxn的矩阵A可逆，当且仅当A行等价于单位阵I，此时，把A变为单位阵的一系列初等行变换同时把单位阵I变为矩阵A的逆矩阵。</code></pre><h5 id="求逆矩阵的算法">求逆矩阵的算法</h5><p>将矩阵$A$和单位阵$I$排在一起写为增广矩阵的形式$\begin{bmatrix}A &amp; I \end{bmatrix}$,对增广矩阵进行行变换时，$A$与$I$同时进行同一变换，那么如果有一系列的初等行变换将$A$变换到单位阵，那么$I$将变换得到矩阵$A^{-1}$,否则$A$没有逆矩阵。</p><p>注意：更有实际意义的一个观点是，将增广矩阵$\begin{bmatrix}A &amp; I \end{bmatrix}$变换为$\begin{bmatrix}I &amp; A^{-1} \end{bmatrix}$实际上是在解n个方程组：</p><p>$$<br>A\mathbf{x}=e_1,A\mathbf{x}=e_2,…,A\mathbf{x}=e_n<br>$$</p><p>其中$e_i$是$n$维单位向量。<br><strong>实际应用中并不需要求解所有方程组，只需要求解需要的$A\mathbf{x}=e_i$的解即可。</strong></p><h4 id="矩阵的因式分解">矩阵的因式分解</h4><h5 id="LU分解">LU分解</h5><p>设矩阵$A$为$m\times n$矩阵，$A=LU$，其中$L$为$m\times m$单位下三角矩阵，$U$为$m\times n$为与$A$等价的阶梯型矩阵。LU分解是用来求解线性方程组的一种方法。当矩阵$A=LU$时，方程组$Ax=b$可写为$L(Ux)=L(y)$，即转换为求解两个方程组：</p><p>$$<br>Ly=b<br>$$</p><p>$$<br>Ux=y<br>$$</p><p>这两个方程都很容易求解，因为它们都是三角矩阵。</p><p>LU分解的步骤：<br>设$A$可以仅用行倍加变换化简为阶梯型矩阵$U$。即存在一系列单位下三角初等矩阵$E_1,E_2,…,E_p$，使得$E_p \cdots E_1 A=U$。于是，$A=(E_p \cdots E_1)^{-1}U=LU$.<br>其中$L=(E_p \cdots E_1)^{-1}$</p><p><strong>有意思的是，我们需要注意到，将A转换成U的一系列行变换，同时也将L转换成I。这是因为，$E_p \cdots E_1 A=U$，因此，$E_p \cdots E_1 L = I$。那么显然，因为$U$的下三角部分均为$0$,$I$的下三角部分也均为$0$,因此$L$的下三角部分其实为A的下三角部分除以其对应主元列元素的结果。</strong></p><h4 id="子空间">子空间</h4><p>定义：$R^n$中的子空间是指,$R^n$中的集合$H$，满足：</p><ol><li>$H$中任意两个向量$\mathbf{x},\mathbf{y}\in H$，$\mathbf{x}+\mathbf{y}\in H$</li><li>$\mathbf{x}\in H$，$\lambda\mathbf{x}\in H$ ($\lambda \in R$)</li><li>零向量$\mathbf{0}\in H$</li></ol><p>子空间的性质：<br>1.矩阵$A$的列空间$Col(A)$是指$A$的列向量各线性组合构成的集合。且是矩阵$A$的主元列向量构成的集合。<br>2.矩阵$A$的零空间$Nul(A)$是指$A$的零空间，即$A\mathbf{x}=0$的解$\mathbf{x}$构成的集合。且是矩阵$A$的自由变量构成的集合。</p><h5 id="子空间的基">子空间的基</h5><p>设$H$为$R^n$中的子空间，$H$的基是指$H$中向量的集合$B$，使得$H=Span{ \mathbf{b}_1,\mathbf{b}_2,\cdots,\mathbf{b}_k }$，其中$\mathbf{b}_1,\mathbf{b}_2,\cdots,\mathbf{b}_k$是$H$中的线性无关向量。</p><h4 id="维数与秩">维数与秩</h4><h5 id="坐标系">坐标系</h5><p>假设$B={\mathbf{b}_1,\mathbf{b}_2,\cdots,\mathbf{b}_k}$是$H$的一个基，对$\mathbf{H}$中的每一个向量$\mathbf{x}$，可以用基$B$中的向量${\mathbf{b}_1,\mathbf{b}_2,\cdots,\mathbf{b}_k}$的坐标表示：</p><p>$$<br>\mathbf{x}=\sum_{i=1}^k \alpha_i\mathbf{b}_i<br>$$</p><p>其中$\alpha_1,\alpha_2,\cdots,\alpha_k$是$\mathbf{x}$在基$B$中的坐标。</p><h5 id="维数">维数</h5><p>非零子空间$H$的维数是指，用$dim(H)$表示,是指$H$中任意一个基的向量的个数。</p><h5 id="秩">秩</h5><p>矩阵$A$的秩，记作$rank(A)$，是指$A$列空间的维数。</p><p>如果一矩阵$A$有n列，则$n = rank(A) + dim(Nul(A))$。</p><p>秩与可逆矩阵定理：<br>如果一个矩阵$A$可逆，则有：</p><ol><li>$rank(A)=n$</li><li>$A$的列向量构成一个$R^n$的基.</li><li>$Col(A)=R^n$</li><li>$Nul(A)={0}$</li><li>$dim(Col(A))=n$</li><li>$dim(Nul(A))=0$</li></ol><h3 id="行列式">行列式</h3><p>定义：当$n\ge 2$时，$n\times n$矩阵$A$的行列式$det(A)$是形如$±a_{1j}detA_{1j}$的n个项的和，其中加减号在交替出现，其中元素$a_{1j}$是$A$的第1行第j列元素。</p><p>$$<br>detA = a_{11}detA_{11} - a_{12}detA_{12} + a_{13}detA_{13} - \cdots + (-1)^{n+1}a_{1n}detA_{1n}\<br>= \sum_{j=1}^n (-1)^{j+1}a_{1j}detA_{1j}<br>$$</p><p>余因子展开式：$A$的$(i,j)$余因子$C_{ij}$由下式给出：</p><p>$$<br>C_{ij} = (-1)^{i+j}detA_{ij}<br>$$</p><p>于是有，</p><p>$$<br>detA = \sum_{j=1}^n a_{1j}C_{1j}<br>$$</p><h4 id="行列式的性质">行列式的性质</h4><p>行变换定理：若A是n阶方阵，</p><ol><li>若A的第i行与第j行交换，则detA的符号改变；</li><li>若A的某一行的倍数加到另一行得到矩阵B，则$detA = detB$。</li><li>若A的某行乘以倍数k得到矩阵B，则$detB = k\cdot detA$。</li></ol><p>定理：若A 为三角阵，则detA等于A的主对角线上元素的乘积。</p><p><strong>计算行列式可以将其化为三角矩阵来进行求解。</strong></p><p>转置：<br>方阵A的转置的行列式等于A的行列式。即$det(A^T) = detA$。</p><p>乘法：<br>若方阵A与B均为$n \times n$矩阵，则$detAB = detA\cdot detB$。</p><h4 id="克拉默法则">克拉默法则</h4><p>定义对任意$n\times n$矩阵$A$和$R^n$中的向量$\mathbf{b}$，$A_i(\mathbf{b})$*表示A中第i列由向量$\mathbf{b}$替换得到的矩阵。</p><p>$$<br>A_i(\mathbf{b}) = [\mathbf{a_1} \cdots \mathbf{b} \cdots \mathbf{a_n}]<br>$$</p><p>克拉默法则：<br>设$A$是一个可逆的$n \times n$矩阵，$\mathbf{b}$是一个$n$维向量，方程$A\mathbf{x}=\mathbf{b}$的唯一解$\mathbf{x}$存在，可由下式给出：</p><p>$$<br>x_i = \frac{detA_i(\mathbf{b})}{detA},i=1,2,\cdots,n<br>$$</p><p>逆矩阵公式：</p><p>$$<br>A^{-1} = \frac{1}{detA}\begin{bmatrix}<br>C_{11} &amp; C_{21} &amp; \cdots &amp; C_{n1}\<br>C_{12} &amp; C_{22} &amp; \cdots &amp; C_{n2}\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>C_{1n} &amp; C_{2n} &amp; \cdots &amp; C_{nn}<br>\end{bmatrix}<br>$$</p><p>其中$C_{ij}$是$A$的$(i,j)$余因子，所构成的矩阵称为伴随矩阵，记作$adjA$。</p><h3 id="向量空间与子空间">向量空间与子空间</h3><p>向量空间的定义：<br>一个向量空间是由一些被称为向量的对象构成的非空集合$\mathbf{V}$,以及两个运算：</p><ol><li>加法：$\mathbf{v},\mathbf{w}\in\mathbf{V}$，$\mathbf{v}+\mathbf{w}\in \mathbf{V}$</li><li>标量乘法：$\alpha \in R,\mathbf{v}\in\mathbf{V}$，$\alpha\mathbf{v}\in\mathbf{V}$并且有以下公理：</li><li>$\mathbf{u}+\mathbf{v}=\mathbf{v}+\mathbf{u}$</li><li>$(\mathbf{u}+\mathbf{v})+\mathbf{w}=\mathbf{u}+(\mathbf{v}+\mathbf{w})$</li><li>$\mathbf{V}$中存在一个零向量$\mathbf{0}$，使得$\forall\mathbf{v}\in\mathbf{V},\mathbf{v}+\mathbf{0}=\mathbf{v}$。</li><li>对每一个$\mathbf{v}\in\mathbf{V}$，存在一个负向量$\mathbf{-v}$，使得$\mathbf{v}+\mathbf{-v}=\mathbf{0}$。</li><li>$c(\mathbf{v}+\mathbf{w})=c\mathbf{v}+c\mathbf{w}$</li><li>$(a+b)\mathbf{v}=a\mathbf{v}+b\mathbf{ v}$</li><li>$c(d\mathbf{v})=(cd)\mathbf{v}$</li><li>$1\mathbf{v}=\mathbf{v}$</li></ol><h4 id="子空间-2">子空间</h4><p>定义：设$\mathbf{V}$是一个向量空间，$\mathbf{H}\subset\mathbf{V}$，如果$\mathbf{H}$是一个子空间如果满足以下三个性质：<br>a. $\mathbf{H}$中存在一个零向量$\mathbf{0}$<br>b. $\mathbf{H}$对向量加法封闭，即$\forall\mathbf{v}\in\mathbf{H},\forall\mathbf{w}\in\mathbf{H},\mathbf{v}+\mathbf{w}\in\mathbf{H}$<br>c. $\mathbf{H}$对标量乘法封闭，即$\forall\alpha\in R,\forall\mathbf{v}\in\mathbf{H},\alpha\mathbf{v}\in\mathbf{H}$</p><p><strong>定理</strong>：若$v_1,v_2,\cdots,v_n$是$\mathbf{V}$中的向量，则$Span{v_1,v_2,\cdots,v_n}$是$\mathbf{V}$的一个子空间。</p><h4 id="矩阵的零空间">矩阵的零空间</h4><p>定义：设$A$是一个$m\times n$矩阵，$\mathbf{v}\in R^n$，则$A\mathbf{v}=0$的解集称为矩阵$A$的零空间。表示为：</p><p>$$<br>Nul(A) = { \mathbf{v}\in R^n : A\mathbf{v}=0 }<br>$$</p><p><strong>定理</strong>：$A$是一个$m\times n$矩阵，则$Nul(A)$是$R^n$的一个子空间。等价地说，m个方程，n个未知数的齐次线性方程组$Ax=0$的解集是$R^n$的一个子空间。</p><h4 id="列空间">列空间</h4><p>定义：设$A$是一个$m\times n$矩阵，则$A$的列的所有线性组合组成的集合是$A$的列空间，记作$Col(A)=Span{ \mathbf{a}_1,\mathbf{a}_2,\cdots,\mathbf{a}_n}$。</p><p><strong>定理</strong>：$A$是一个$m\times n$矩阵，则$Col(A)$是$R^m$的一个子空间。<br>注意到，$Col(A)$可以写为</p><p>$$<br>Col(A) = {\mathbf{b}:\mathbf{b}=A\mathbf{x},\mathbf{x}\in R^n},\mathbf{x}为某向量。<br>$$</p><h4 id="线性变换的核与值域">线性变换的核与值域</h4><p>定义：设$T:V\to W$是一个线性变换，它将$\mathbf{V}$中的每个向量$\mathbf{v}$映射到$\mathbf{W}$中的一个向量唯一向量$\mathbf{w} = T(v)$,并且满足：</p><ol><li>$T(\mathbf{u}+\mathbf{v})=T(\mathbf{u})+T(\mathbf{v})$</li><li>$T(\alpha\mathbf{v})=\alpha T(\mathbf{v})$, 对所有$\alpha\in R$和$\forall\mathbf{v}\in\mathbf{V}$均成立。</li></ol><p><strong>线性变换T的核(kernel)</strong>：<br>设$T:V\to W$是一个线性变换，则线性变换T的核是$\mathbf{V}$中所有满足$T(\mathbf{v})=\mathbf{0}$的向量的集合。记作$ker(T)$。T的值域是$\mathbf{W}$中所有具有形式$T(v)(\forall v\in V)$的向量的集合。</p><p>如果一个线性变换T是由一个矩阵变换得到的，即$T(x)=Ax$，则T的值域与核恰好是A的列空间核与零空间。</p><h4 id="基">基</h4><p>定义：设$\mathbf{V}$是一个向量空间，令$\mathbf{H}$是向量空间$\mathbf{V}$的一个子空间，$\mathbf{V}$中向量的指标集$\mathbf{B}={\mathbf{b}_1,\mathbf{b}_2,\cdots,\mathbf{b}_m}$称为$\mathbf{H}$的一个基，如果有：</p><ol><li>$\mathbf{B}$是一个线性无关集。</li><li>由$\mathbf{B}$生成的子空间与$\mathbf{H}$相同。</li></ol><p><strong>定理</strong>：矩阵A的主元列构成了A的列空间的基。</p><p><strong>生成集定理：</strong> 令$S={v_1,v_2,\cdots,v_n}$是$\mathbf{V}$中的向量集，且有$H=Span{v_1,v_2,\cdots,v_n}$<br>a. 若$S$中的某一个向量$\mathbf{v_k}$，是S其余向量的线性组合，则S去掉$\mathbf{v_k}$后形成的集合仍然能够生成$\mathbf{H}$。<br>b. 若$H\neq {\mathbf{0}}$,则S的某一子集是H的一个基。</p><h5 id="坐标系-2">坐标系</h5><p>对于向量空间$V$中的一组基$B={b_1,b_2,\cdots,b_n}$，则对$V$中的每个向量$x$，可以用基$B$中的元素表示为：</p><p>$$<br>\mathbf{x} = \sum_{i=1}^n a_i\mathbf{b_i}<br>$$</p><p>于是，定义$\mathbf{x}$相对于基$B$的坐标是使得$\mathbf{x}=\sum_{i=1}^n a_i\mathbf{b_i}$的权$a_1,a_2,\cdots,a_n$。记作</p><p>$$<br>[\mathbf{x}]_B = \begin{bmatrix}<br>a_1\<br>a_2\<br>\vdots\<br>a_n<br>\end{bmatrix}<br>$$</p><p>令</p><p>$$<br>P_B = [\mathbf{b_1},\mathbf{b_2},\cdots,\mathbf{b_n}]<br>$$</p><p>则$\mathbf{x}=a_1\mathbf{b_1}+a_2\mathbf{b_2}+\cdots+a_n\mathbf{b_n}$等价于$\mathbf{x}=P_B[\mathbf{x}]_B$.称$P_B$为从$B$到$R^n$的<strong>坐标变换矩阵</strong>。</p><h4 id="向量空间的维数">向量空间的维数</h4><p>若向量空间$\mathbf{V}$中存在一组基${\mathbf{b}_1,\mathbf{b}_2,\cdots,\mathbf{b}_n}$，则$\mathbf{V}$中任意包含多于n个向量的集合一定线性相关。</p><p><strong>定理</strong>：若向量空间$\mathbf{V}$是由一个有限集生成的，则称$\mathbf{V}$为有限维的，其维数写为$dim(\mathbf{V})$。是指$\mathbf{V}$的基中含有向量的个数。零向量空间 ${\mathbf{0}}$ 的维数定义为0。反之，如果$\mathbf{V}$不是由一有限集生成，那么其称为无穷维的。</p><p><strong>定理</strong>：令$\mathbf{H}$为$\mathbf{V}$的一个子空间，则$\mathbf{H}$中任意一个线性无关集均可以扩充为$\mathbf{H}$的一个基，$\mathbf{H}$也是有限维的，且有：</p><p>$$<br>dim(\mathbf{H}) \leq dim(\mathbf{V})<br>$$</p><pre><code class="hljs">NulA的维数是方程Ax=0中自由变量的个数，ColA的维数是A中主元列的个数。</code></pre><h4 id="秩-2">秩</h4><p><strong>定理</strong>：若两个矩阵$A$和$B$行等价，则它们的行空间相同。若B为阶梯型矩阵，则B的非零行构成A的行空间的一个基的同时也构成了B的行空间的一个基。</p><p><strong>A的秩即为A的列空间的维数。</strong></p><p><strong>秩定理</strong>：设$A$为$m\times n$矩阵，A的行空间与列空间的维数相等，这个维数称为A的秩，还等于A的主元位置的个数且满足：</p><p>$$<br>rank(A) + dim(NulA) = n<br>$$</p><p><strong>秩与可逆矩阵定理</strong>：设$A$为$n\times n$矩阵，如果A是可逆矩阵,则有：</p><ol><li>A的列构成$R^n$的一个基。</li><li>$ColA=R^n$</li><li>$dimColA=n$</li><li>$rank(A)=n$</li><li>$NulA={\mathbf{0}}$</li><li>$dim(NulA)=0$</li></ol><p>注意到：A的行空间是$A^T$的列空间，又A可逆当且仅当$A^T$可逆。，所以对上述一系列判读可逆矩阵同样适用于$A^T$。</p><h4 id="基变换">基变换</h4><p>设$B={\mathbf{b_1},\mathbf{b_2},\cdots,\mathbf{b_n}}$与$C={\mathbf{c_1},\mathbf{c_2},\cdots,\mathbf{c_n}}$是向量空间$\mathbf{V}$的两个基，则存在一个$n \times n$矩阵$P$，使得：</p><p>$$<br>[\mathbf{x}]_C = P[\mathbf{x}]_B<br>$$</p><p>且，$P$的列是基$B$中向量的$C-坐标向量$，即：</p><p>$$<br>P = \begin{bmatrix}<br>[\mathbf{b_1}]_C,<br>[\mathbf{b_2}]_C,<br>\cdots<br>[\mathbf{b_n}]_C<br>\end{bmatrix}<br>$$</p><p>若$B={\mathbf{b_1},\mathbf{b_2},\cdots,\mathbf{b_n}}$，$E$是$R^n$的标准基${\mathbf{e}_1,\mathbf{e}_2,\cdots,\mathbf{e}_n}$，则$[\mathbf{b_1}]<em>E=\mathbf{b_1}$,$B$中的其他向量也类似，引入坐标变换矩阵$P</em>{E\leftarrow B}$,则其与$P_B$等价。</p><h4 id="马尔科夫链的矩阵形式">马尔科夫链的矩阵形式</h4><p>定义：<br><strong>概率向量</strong>：一个具有非负分量，且各分量的数值相加等于1的向量称为概率向量。<br><strong>概率矩阵</strong>：随机矩阵是指各列向量都是概率向量的矩阵。<br><strong>马尔科夫链</strong>：一个马尔科夫链是一个概率向量序列$\mathbf{x_1},\mathbf{x_2},\cdots,\mathbf{x_n}$和一个随机转移矩阵$P$，满足：</p><p>$$<br>\mathbf{x_i} = P\mathbf{x_{i-1}},i=2,3,\cdots,n0<br>$$</p><p>$\mathbf{x_k}$中的数值分别列出来一个系统在n各可能状态下的概率，或者实验结果是n个可能概率之一的概率。因此，$\mathbf{x_k}$通常被称为状态向量。</p><p><strong>稳态向量</strong>：若P是一个随机矩阵，则相对于P的稳态向量是一个满足:</p><p>$$<br>P\mathbf{q}=\mathbf{q}<br>$$</p><p>的概率向量$\mathbf{q}$。每一个随机矩阵都有一个稳态向量。</p><p><strong>定理</strong>：若P是一个$n\times n$正规的随机矩阵，则P具有唯一的稳态向量$\mathbf{q}$.进一步的，如果$\mathbf{x_0}$是<strong>任一个</strong>起始状态，且有$\mathbf{x_{k+1}}=P\mathbf{x_k},k=0,1,\cdots$,则当$k\rightarrow\infty$时，马尔科夫链${\mathbf{x_k}}$收敛到稳态向量$\mathbf{q}$.</p><h3 id="特征值与特征向量">特征值与特征向量</h3><p>定义：$\mathbf{A}$为$n \times n$矩阵，$\mathbf{x}$为非零向量，若存在数$\lambda$使得$\mathbf{Ax}=\lambda \mathbf{x}$成立，则称$\lambda$为$\mathbf{A}$的特征值，$\mathbf{x}$称为对应于$\lambda$的特征向量。</p><p><strong>定理</strong>：三角矩阵的主对角线元素是特征值。</p><p>注意：$\lambda$是$A$的特征值当且仅当</p><p>$$<br>(A-\lambda I)\mathbf{x}=\mathbf{0}<br>$$</p><p><strong>定理</strong>：$\lambda_1,\cdots,\lambda_r$是$n \times n$矩阵A相异的特征值，$\mathbf{v}_1,\cdots,\mathbf{v}_r$是与$\lambda_1,\cdots,\lambda_r$对应的特征向量,那么向量集合${\mathbf{v}_1,\cdots,\mathbf{v}_r}$线性无关。</p><h4 id="特征方程">特征方程</h4><p>求解特征方程是指，找出所有的$\lambda$，使得$\mathbf{A}\mathbf{x}=\lambda\mathbf{x}$成立。等价于要求出所有的$\lambda$,使得矩阵$\mathbf{A}-\lambda I$为不可逆矩阵。</p><p>行列式与特征方程：设A为$n\times n$矩阵，则$\mathbf{A}$是可逆的当且仅当<br>1.0不是A的特征值。<br>2.A的行列式不为0。</p><h4 id="行列式的性质-2">行列式的性质</h4><p>设A和B为$n\times n$矩阵，则：<br>a. A可逆的充分必要条件是A的行列式不为0。<br>b. $det(AB)=det(A)det(B)$<br>c. $detA^T=detA$<br>d.若$A$是三角矩阵，那么$detA$是$A$的主对角线元素的乘积。<br>e.对$A$作行替换不改变院行列式的值，做一次行交换使其行列式值的符号改变一次。数乘一行后，行列式的值等于用此数乘原来的行列式。</p><p><strong>定理</strong>：数$\lambda$是$n \times n$矩阵A的特征值的充分必要条件是$\lambda$是特征方程$det(A-\lambda I)=0$的根。</p><h4 id="相似性">相似性</h4><p>设A和B为$n\times n$矩阵，如果存在可逆矩阵P，使得$P^{-1}AP=B$，或者等价地$A=PBP^{-1}$，则称A相似于B。记$Q=P^{-1}$，则有$Q^{-1}BQ=A$,即B也相似于A。把A变为$P^{-1}AP$的变换称为相似变换。</p><p><strong>定理</strong>：如果$n\times n$矩阵A与B是相似的，那么它们有相同的特征多项式，从而有相同的特征值。</p><h4 id="对角化">对角化</h4><p>如果$n\times n$矩阵A相似于对角矩阵，即存在可逆矩阵P和对角矩阵D，有$A=P^{-1}DP$，则称A为可对角化矩阵。</p><p><strong>定理</strong>：如果$n\times n$矩阵A可对角化可对角化的充分必要条件是$\mathbf{A}$有n个线性无关的特征向量。事实上，$A=P^{-1}DP$,D为对角矩阵的充分必要条件是P的列向量是A的n个线性无关的特征向量。此时，D中对角线上的元素分别是A的对应于P中特征向量的特征值。</p><p>注意到，A可对角化也就是说有足够的特征向量形成$R^n$的一个基，我们称这组基为特征向量基。</p><p><strong>定理</strong>：有n个相异特征值的$n\times n$矩阵可对角化。（是充分的，但不是充要的）</p><h4 id="微分方程中的应用">微分方程中的应用</h4><p>(待续)</p><h3 id="正交性和最小二乘法">正交性和最小二乘法</h3><p>向量的长度：向量 $\mathbf{v}$的长度（范数）是非负数$||\mathbf{v}||$，定义为：</p><p>$$<br>||\mathbf{v}||=\sqrt{\mathbf{v} \cdot \mathbf{v}}=\sqrt{\sum_{i=1}^n v_i^2} 且 ||\mathbf{v}||^2 = \mathbf{v} \cdot \mathbf{v}<br>$$</p><p>对于任意数$c \in \mathbb{R}$，有：</p><p>$$<br>c||\mathbf{v}||= \left |c \right|  \left \Vert \mathbf{v} \right \Vert<br>$$</p><p>长度为1的向量称为单位向量，如果把一个非零向量除以自身长度，即乘以$1/||\mathbf{v}||$，那么得到的向量就是单位向量，这称为向量$\mathbf{v}$的单位化。</p><p>$\mathbb{R}^n$空间中的向量$\mathbf{v}$和$\mathbf{w}$的距离，记作$dist(\mathbf{v},\mathbf{w})$，定义为：</p><p>$$<br>dist(\mathbf{v},\mathbf{w})=\left \Vert \mathbf{v}-\mathbf{w} \right \Vert = \sqrt{(\mathbf{v}-\mathbf{w}) \cdot (\mathbf{v}-\mathbf{w})}<br>$$</p><h4 id="正交向量">正交向量</h4><p>如果向量$\mathbf{v} \cdot \mathbf{w}=0$，则称$\mathbf{v}$和$\mathbf{w}$是相互正交的，记作$\mathbf{v} \perp \mathbf{w}$。</p><p><strong>毕达哥斯拉定理</strong>：两个向量$\mathbf{v}$和$\mathbf{w}$相互正交的充要条件是${\left \Vert \mathbf{v}+\mathbf{w} \right \Vert}^2=\left \Vert \mathbf{v} \right \Vert^2+\left \Vert \mathbf{w} \right \Vert^2$。</p><h4 id="正交补">正交补</h4><p>如果向量$\mathbf{z}$与$\mathbb{R}^n$的子空间$\mathbf{W}$中的任意向量都正交，则称$\mathbf{z}正交于\mathbf{W}$。那么与子空间$\mathbf{W}$正交的向量$\mathbf{z}$的集合称为$\mathbf{W}$的正交补，记作$\mathbf{W}^{\perp}$。</p><p><strong>定理1</strong>：</p><ol><li>向量$\mathbf{x}$属于$\mathbf{W}^{\perp}$的充分必要条件是向量$\mathbf{x}$与生成空间$\mathbf{W}$中任一向量$\mathbf{w}$都不正交。</li><li>$\mathbf{W}^{\perp}$是$\mathbb{R}^n$的一个子空间。</li></ol><p><strong>定理2</strong>：假设矩阵$\mathbf{A}$是$m\times n$的矩阵，那么$\mathbf{A}$的行向量空间的正交补空间是$\mathbf{A}$的零空间，且$\mathbf{A}$的列向量空间的正交补是$\mathbf{A}^{\intercal}$的零空间:</p><p>$$<br>(Row A)^{\perp}= Nul(A) \quad  且\quad(Col A)^{\perp}= Nul(A^T)<br>$$</p><h4 id="正交集">正交集</h4><p>$\mathbb{R}^n$中的向量集合${\mathbf{v}_1,\mathbf{v}_2,\cdots,\mathbf{v}_k}$称为正交向量集，如果集合中任意两个不同的向量都正交，即当$i \neq j$时,有$\mathbf{v}_i \perp \mathbf{v}_j$。</p><p><strong>定理3</strong>：如果$S={\mathbf{u}_1,\mathbf{u}_2,\cdots,\mathbf{u}_k}$是$\mathbb{R}^n$中的非零向量构成的正交向量集，那么$S$是线性无关集，因此构成所生成子空间$\mathbf{S}$的一组基。</p><p><strong>定理4</strong>：假设${\mathbf{u}_1,\mathbf{u}_2,\cdots,\mathbf{u}_p}$是$\mathbb{R}$中子空间$\mathbb{W}$的正交基，则对$\mathbb{W}$中的每个向量$\mathbf{y}$，线性组合$\mathbf{y}=c_1\mathbf{u}_1+c_2\mathbf{u}_2+\cdots+c_p\mathbf{u}_p$的系数$c_1,c_2,\cdots,c_p$中的权值可以由$c_j=\frac{\mathbf{y} \cdot \mathbf{u}_j}{\mathbf{u}_j \cdot \mathbf{u}_j} \quad (j=1,2,\cdots,p)$给出。</p><h4 id="正交投影">正交投影</h4><p>考虑$\mathbb{R}^n$中的一个向量$\mathbf{y}$分解为两个向量之和的问题，一个向量是$\mathbf{u}$的数量乘积，另一个向量与$\mathbf{u}$垂直，其中向量$\mathbf{u}$是给定的。写为：</p><p>$$<br>\mathbf{y}= \mathbf{\hat{y}}+\mathbf{z}<br>$$</p><p>其中，$\mathbf{\hat{y}}=\alpha \mathbf{u} \quad \alpha是个数$，$\mathbf{z}$是一个垂直于$\mathbf{u}$的向量。</p><p>可以求得，<br>$\alpha = \frac{\mathbf{y} \cdot \mathbf{u}}{\mathbf{u} \cdot \mathbf{u}}$<br>$\mathbf{\hat{y}}=\frac{\mathbf{y}\cdot\mathbf{u}}{\mathbf{u} \cdot \mathbf{u}} \cdot \mathbf{u}$。<br>称向量$\mathbf{\hat{y}}$是$\mathbf{y}$在$\mathbf{u}$上的正交投影，而向量$\mathbf{z}$是$\mathbf{y}$垂直$\mathbf{u}$的分量。</p><p>例子：对于向量空间$\mathbf{W}=\mathbb{R}^2=Span{\mathbf{u}_1,\mathbf{u}_2}$，$\mathbf{u}_1,\mathbf{u}_2$相互正交，那么对于任意$\mathbb{R}^2$中的向量$\mathbf{y}$，都有：</p><p>$$<br>\mathbf{y}=\frac{\mathbf{y}\cdot\mathbf{u}_1}{\mathbf{u}_1 \cdot \mathbf{u}_1} \cdot \mathbf{u}_1+\frac{\mathbf{y}\cdot\mathbf{u}_2}{\mathbf{u}_2 \cdot \mathbf{u}_2} \cdot \mathbf{u}_2<br>$$</p><h4 id="单位正交集">单位正交集</h4><p>集合${\mathbf{u}_1,\cdots,\mathbf{u}_n}$是一个单位正交集，如果它们是由单位向量构成的正交集。如果$\mathbf{W}$是一个由单位正交集组成的子空间，那么${\mathbf{u}_1,\cdots,\mathbf{u}_n}$是$\mathbf{W}$的<strong>单位正交基</strong>，因为这类集合自然线性无关。</p><p><strong>定理5</strong>：一个$m \times n$矩阵$\mathbf{U}$具有单位正交列向量的充分必要条件是$\mathbf{U}^{\intercal}\mathbf{U}=\mathbf{I}$。</p><p><strong>定理6</strong>：假设$\mathbf{U}$是一个具有单位正交列向量的$m \times n$矩阵，且$\mathbf{x}$和$\mathbf{y}$是$\mathbb{R}^n$中的向量，那么：<br>a. $\left \Vert U\mathbf{x} \right \Vert=\left \Vert \mathbf{x} \right \Vert$<br>b. $(\left \Vert U\mathbf{x} \right \Vert)(\left \Vert U\mathbf{y} \right \Vert)= \mathbf{x} \cdot \mathbf{y}$<br>c. $(\left \Vert U\mathbf{x} \right \Vert)(\left \Vert U\mathbf{y} \right \Vert)=0$的充要条件是$\mathbf{x} \perp \mathbf{y}$。<br>这些性质表明：<strong>线性映射$\mathbf{x}\mapsto U\mathbf{x}$保持长度和正交性</strong>。</p><p>定理5和定理6表明一个 <strong>正交矩阵</strong> 就是一个可逆的方阵$U$,且满足：$U^T=U^{-1}$。这样的矩阵具有单位正交列，且任何具有单位正交列的方阵是正交矩阵。</p><h4 id="正交分解">正交分解</h4><p><strong>正交分解定理</strong>：若$W$是$\mathbb{R}^n$的子空间，那么$\mathbb{R}^n$中的每一个向量$\mathbf{y}$都可以唯一表示为：</p><p>$$<br>\mathbf{y}=\mathbf{\hat{y}}+\mathbf{z}<br>$$</p><p>其中$\mathbf{\hat{y}}$属于$\mathbf{W}$，$\mathbf{z}$属于$\mathbf{W}^{\perp}$。如果${\mathbf{u}_1,\mathbf{u}_2,\cdots,\mathbf{u}_p}$是$\mathbf{W}$的正交基，那么$\mathbf{y}$可以唯一表示为：</p><p>$$<br>\mathbf{y}=\sum_{i=1}^p \frac{\mathbf{y}\cdot\mathbf{u}_i}{\mathbf{u}_i \cdot \mathbf{u}_i} \mathbf{u}_i<br>$$</p><p>且$\mathbf{z}=\mathbf{y}-\mathbf{\hat{y}}$。式中，$\mathbf{\hat{y}}$称为 <strong>$\mathbf{y}$在$W$上的正交投影</strong>，记作$proj_w(\mathbf{y})$。</p><p><strong>正交投影的性质</strong>：如果${\mathbf{u}_1,\mathbf{u}_2,\cdots,\mathbf{u}_p}$是$\mathbf{W}$的正交基，且如果$\mathbf{y}$属于$\mathbf{W}$，那么$proj_w(\mathbf{y})=\mathbf{y}$。</p><p><strong>最佳逼近定理</strong>：假设$W$是一个$\mathbb{R}^n$的子空间，$\mathbf{y}$是$\mathbb{R}^n$中的任意向量，$\mathbf{\hat{y}}$是$\mathbf{y}$在$W$上的正交投影，那么$\mathbf{\hat{y}}$是$W$上最接近$\mathbf{y}$的点，也就是</p><p>$$<br>\left \Vert \mathbf{y}-\mathbf{\hat{y}} \right \Vert \leq \left \Vert \mathbf{y}-\mathbf{v} \right \Vert<br>$$</p><p>对于所有属于$W$又异于$\mathbf{\hat{y}}$的向量$\mathbf{v}$成立。</p><p><strong>定理7</strong>：如果${\mathbf{u}_1,\mathbf{u}_2,\cdots,\mathbf{u}_p}$是$\mathbb{R}^n$中子空间$\mathbf{W}$的单位正交基，那么：</p><p>$$<br>proj_w(\mathbf{y})=(\mathbf{y}\cdot\mathbf{u}_1)\mathbf{u}_1+\cdots+(\mathbf{y}\cdot\mathbf{u}_p)\mathbf{u}_p<br>$$</p><p>如果$U=[\mathbf{u}_1\ \cdots\ \mathbf{u}_p]$,则：</p><p>$$<br>proj_w(\mathbf{y})=UU^T\mathbf{y},对所有\mathbf{y}\in\mathbb{R}^n成立<br>$$</p><h4 id="格拉姆-施密特方法">格拉姆-施密特方法</h4><p>格拉姆-施密特方法是对$\mathbb{R}^n$中任何非零子空间构造正交集或标准正交集的简单算法。</p><p><strong>步骤</strong>：<br>对$\mathbb{R}^n$中的子空间的一个基${\mathbf{x}_1,\mathbf{x}_2,\cdots,\mathbf{x}_p}$，定义：</p><p>$$<br>\mathbf{v}_1=\mathbf{x}_1\<br>\mathbf{v}_2=\mathbf{x}_2-\frac{\mathbf{x}_2 \cdot \mathbf{v}_1}{\mathbf{v}_1\cdot\mathbf{v}_1}\mathbf{v}_1\<br>\cdots\<br>\mathbf{v}_p=\mathbf{x}_p-\frac{\mathbf{x}_p \cdot \mathbf{v}_1}{\mathbf{v}_1\cdot\mathbf{v}_1}\mathbf{v}_1-\frac{\mathbf{x}_p \cdot \mathbf{v}_2}{\mathbf{v}<em>2\cdot\mathbf{v}<em>2}\mathbf{v}<em>2+\cdots-\frac{\mathbf{x}<em>p \cdot \mathbf{v}</em>{p-1}}{\mathbf{v}</em>{p-1}\cdot\mathbf{v}</em>{p-1}}\mathbf{v}</em>{p-1}<br>$$</p><p>那么${\mathbf{v}_1,\mathbf{v}_2,\cdots,\mathbf{v}_p}$就是$\mathbf{W}$的一个正交基，此外</p><p>$$<br>Span{\mathbf{v}_1,\mathbf{v}_2,\cdots,\mathbf{v}_p}=Span{\mathbf{x}_1,\mathbf{x}_2,\cdots,\mathbf{x}_k},其中1\leq k\leq p<br>$$</p><p>注意到，如果需要得到一个标准正交基，只需要单位化所有的向量$\mathbf{v}_k$即可。</p><p><strong>QR分解</strong>：如果$m \times n$矩阵$\mathbf{A}$的列线性无关，$\mathbf{A}$可以分解为$A=QR$，其中$Q$是一个$m \times n$的矩阵，其列形成了$ColA$的一个标准正交基，$R$是一个$n \times n$的上三角矩阵可逆矩阵且在对角线上的元素为正数。</p><p>应用：$A$的列向量构成$ColA$的一个基${\mathbf{x}_1,\mathbf{x}_2,\cdots,\mathbf{x}_n}$,构造$W=ColA$的一个标准正交基${\mathbf{u}_1,\mathbf{u}_2,\cdots,\mathbf{u}_n}$，这个基可以由格拉姆-施密特方法构造。<br>取</p><p>$$<br>Q= [\mathbf{u}_1\ \cdots\ \mathbf{u}_n]<br>$$</p><p>对$k=1,2,\cdots,n$，$\mathbf{x_k}$属于$Span{\mathbf{x}<em>1,\mathbf{x}<em>2,\cdots,\mathbf{x}</em>{k}}=Span{\mathbf{u}<em>1,\mathbf{u}<em>2,\cdots,\mathbf{u}</em>{k}}$，所以存在常数$r</em>{1k},r</em>{2k},\cdots,r_{kk}$使得：</p><p>$$<br>\mathbf{x}<em>k=r</em>{1k}\mathbf{u}<em>1+\cdots+r</em>{kk}\mathbf{u}<em>k+0\cdot \mathbf{u}</em>{k+1}+\cdots+0\cdot \mathbf{u}_n<br>$$</p><p>可以假设$r_{kk}\geq 0$(否则，则对$r_{kk}$和$\mathbf{u}_k$都乘以-1)，那这表明$\mathbf{x_k}$是$Q$的列的线性组合，且其权为</p><p>$$<br>\begin{bmatrix}<br>r_{1k}\<br>\vdots\<br>r_{kk}\<br>0\<br>\vdots\<br>0<br>\end{bmatrix}<br>$$</p><p>即$\mathbf{x}_k=Q\mathbf{r}_k$，其中$k=1,2,\cdots,n$。取$R=[\mathbf{r}_1\ \cdots\ \mathbf{r}_n]$,那么</p><p>$$<br>A=[\mathbf{x}_1\ \cdots\ \mathbf{x}_n]=[Q\mathbf{r}_1\ \cdots\ Q\mathbf{r}_n]=QR<br>$$</p><p>注意到，如果Q的列是单位正交向量，则有$Q^TA=Q^T(QR)=IR=R$</p><h4 id="最小二乘法">最小二乘法</h4><p>考虑$A\mathbf{x}$作为$\mathbf{b}$的一个近似，$\mathbf{b}$和$A\mathbf{x}$之间的距离越小，$\left \Vert \mathbf{b}-A\mathbf{x} \right \Vert$近似程度越好。一般的<strong>最小二乘问题</strong>就是找出使得$\left \Vert \mathbf{b}-A\mathbf{x} \right \Vert$尽量小的$\mathbf{x}$。</p><p>定义：如果$m \times n$矩阵$A$和向量$\mathbf{b}$属于$\mathbb{R}^m$,则$A\mathbf{x}=\mathbf{b}$的最小二乘解是$\mathbb{R}$中的向量$\mathbf{\hat{x}}$，使得：</p><p>$$<br>\left \Vert \mathbf{b}-A\mathbf{\hat{x}} \right \Vert \leq \left \Vert \mathbf{b}-A\mathbf{x} \right \Vert<br>$$</p><p>对于所有$\mathbf{x}\in \mathbb{R}^n$成立。</p><p>对于上述问题的$A$和$\mathbf{b}$，应用最佳逼近定理与子空间$ColA$<br>取</p><p>$$<br>\mathbf{\hat{b}}=proj_{ColA}(\mathbf{b})<br>$$</p><p>由于$\mathbf{\hat{b}}$属于$A$的列空间，故方程$A\mathbf{x}=\mathbf{\hat{b}}$是相容的且存在一个属于$\mathbb{R}^n$的$\mathbf{\hat{x}}$使得</p><p>$$<br>\begin{equation}<br>A\mathbf{\hat{x}}=\mathbf{\hat{b}}<br>\end{equation}<br>$$</p><p>由于$\mathbf{\hat{b}}$是$ColA$中最接近$\mathbf{b}$的点，因此一个向量$\mathbf{\hat{x}}$是$A\mathbf{x}=\mathbf{b}$的一个最小二乘解的充分必要条件$\mathbf{\hat{x}}$满足(1)式。这个属于$\mathbb{R}^n$的$\mathbf{\hat{x}}$是由一系列由A的列构造的$\mathbf{\hat{b}}$的权。</p><p>若$\mathbf{\hat{x}}$满足$A\mathbf{\hat{x}}=\mathbf{\hat{b}}$,则由正交分解定理，投影$\mathbf{\hat{b}}$具有性质$\mathbf{b}-\mathbf{\hat{b}}$与$ColA$正交，即$\mathbf{b}-A\mathbf{\hat{x}}$正交于$A$的每一列。如果$\mathbf{a}_j$是$A$的某一列，那么$\mathbf{a}_j \cdot (\mathbf{b}-A\mathbf{\hat{x}})=0$且$\mathbf{a}_j^T\cdot (\mathbf{b}-A\mathbf{\hat{x}})=0$.由于每一个$\mathbf{a}_j^T$是$A^T$的行，于是</p><p>$$<br>A^T(\mathbf{b}-A\mathbf{\hat{x}})=\mathbf{0}<br>$$</p><p>于是</p><p>$$<br>\begin{equation}<br>A^T\mathbf{b}=A^T A\mathbf{\hat{x}}<br>\end{equation}<br>$$</p><p>于是方程(2)表示的线性方程组称为$A\mathbf{x}=\mathbf{b}$的法方程，其解用$\mathbf{\hat{x}}$表示。</p><p><strong>定理8</strong>：方程$A\mathbf{x}=\mathbf{b}$的最小二乘解集和法方程$A^T\mathbf{b}=A^T A\mathbf{\hat{x}}$的非空解集一致。</p><p><strong>定理9</strong>：设$A$是$m \times n$矩阵，则下面的条件是逻辑等价的</p><ol><li>对于$\mathbb{R}^n$中的每个$\mathbf{b}$，方程$A\mathbf{x}=\mathbf{b}$有唯一最小二乘解</li><li>$A$的列是线性无关的</li><li>矩阵$A^T A$是可逆的<br>当上述条件成立时，唯一的最小二乘解$\mathbf{\hat{x}}$可以表示为：</li></ol><p>$$<br>\mathbf{\hat{x}}=(A^T A)^{-1}A^T\mathbf{b}<br>$$</p><p><strong>定理10</strong>：给定一个$m \times n$矩阵$A$，它具有线性无关的列，取$A=QR$是$A$的QR分解，那么对于每一个属于$\mathbb{R}^n$的向量$\mathbf{b}$，方程$A\mathbf{x}=\mathbf{b}$的有唯一的最小二乘解为：</p><p>$$<br>\mathbf{\hat{x}}=R^{-1}Q^T\mathbf{b}<br>$$</p><h4 id="应用">应用</h4><p>(待续)</p><h4 id="内积空间">内积空间</h4><p>定义：向量空间$V$上的内积是一个函数，对每一对属于$V$的向量$\mathbf{u}$和$\mathbf{v}$，存在一个实数$&lt;\mathbf{u},\mathbf{v}&gt;$满足下述公理，其中$\mathbf{u},\mathbf{v}和\mathbf{w}$都是$V$中的向量,$c$是所有数：</p><ol><li>$&lt;\mathbf{u},\mathbf{v}&gt;=&lt;\mathbf{v},\mathbf{u}&gt;$</li><li>$&lt;\mathbf{u}+\mathbf{v},\mathbf{w}&gt;=&lt;\mathbf{u},\mathbf{w}&gt;+&lt;\mathbf{v},\mathbf{w}&gt;$</li><li>$&lt;c\mathbf{u},\mathbf{v}&gt;=c&lt;\mathbf{u},\mathbf{v}&gt;$</li><li>$&lt;\mathbf{u},\mathbf{u}&gt;\geq 0$且$&lt;\mathbf{u},\mathbf{u}&gt;=0$当且仅当$\mathbf{u}=0$</li></ol><p>一个赋予上述内积的向量空间称为内积空间。</p><h5 id="长度、距离和正交性">长度、距离和正交性</h5><p>设$V$是一个内积空间，其内积记作$&lt;\mathbf{u},\mathbf{v}&gt;$.像$\mathbb{R}^n$一样，我们定义一个向量$\mathbf{v}$的长度或范数为：</p><p>$$<br>\left \Vert \mathbf{v} \right \Vert=\sqrt{&lt;\mathbf{v},\mathbf{v}&gt;}<br>$$</p><p>一个 <strong>单位向量</strong>是长度为1的向量，<strong>向量$\mathbf{u}$和$\mathbf{v}$的距离是$\left \Vert \mathbf{u}-\mathbf{v} \right \Vert$</strong>。向量$\mathbf{u}$和向量$\mathbf{v}$<strong>正交</strong>，如果$&lt;\mathbf{u},\mathbf{v}&gt;=0$。</p><p>给定内积空间$V$中的向量$\mathbf{v}$和有限维子空间$W$，我们可以得到：</p><p>$$<br>\left \Vert \mathbf{v} \right \Vert^2=\left \Vert proj_W(\mathbf{v}) \right \Vert^2+\left \Vert \mathbf{v}-proj_W(\mathbf{v}) \right \Vert^2<br>$$</p><p><strong>柯西-施瓦茨不等式</strong>：对于$V$中的任意向量$\mathbf{v}$和$\mathbf{u}$，有：</p><p>$$<br>\left \Vert &lt;\mathbf{v},\mathbf{u}&gt; \right \Vert\leq \left \Vert \mathbf{v} \right \Vert\left \Vert \mathbf{u} \right \Vert<br>$$</p><p><strong>定理11</strong>：对属于$V$的任意向量$\mathbf{v}$和$\mathbf{u}$，有：</p><p>$$<br>\left \Vert \mathbf{u}+\mathbf{v} \right \Vert\leq \left \Vert \mathbf{u} \right \Vert+\left \Vert \mathbf{v} \right \Vert<br>$$</p><h3 id="对称矩阵与二次型">对称矩阵与二次型</h3><p><strong>对称矩阵</strong>是一个$n\times n$方阵，满足$A_T=A$。</p><p><strong>定理1</strong>：如果$A$是对称矩阵，那么不同特征空间的任意两个特征向量是正交的。</p><p>一个矩阵$A$称为可<strong>正交对角化</strong>，如果存在一个正交矩阵$P$(满足$P^{-1}=P^T$)和一个对角矩阵$D$，使得</p><p>$$<br>A=PDP^T=PDP^{-1}<br>$$</p><p><strong>定理2</strong>：一个$n\times n$矩阵$A$可正交对角化当且仅当$A$是对称矩阵。</p><p><strong>谱定理</strong>：矩阵$A$的特征值的集合称为$A$的谱。一个对称的$n\times n$矩阵$A$有如下性质：</p><ol><li>$A$有n个实特征值，包含重复的特征值。</li><li>对每一个特征值$\lambda$，对应的特征空间的维数等于$\lambda$作为特征方程的根的重数。</li><li>特征空间相互正交，这种正交性是在特征向量对应于不同特征值的意义下成立的。</li><li>$A$可正交对角化</li></ol><h4 id="谱分解">谱分解</h4><p>假设$A=PDP^{-1}$，其中$P$的列是$A$的单位正交特征向量${\mathbf{u}_1,\mathbf{u}_2,\cdots,\mathbf{u}_n}$,且对应的特征值为${\lambda_1,\lambda_2,\cdots,\lambda_n}$,属于对角矩阵$D$。由于$P^T=P^{-1}$，所以:</p><p>$$<br>A = \lambda_1 \mathbf{u}_1^T \mathbf{u}_1 + \lambda_2 \mathbf{u}_2^T \mathbf{u}_2 + \cdots + \lambda_n \mathbf{u}_n^T \mathbf{u}_n<br>$$</p><p>将$A$分解为由$A$的谱确定的小块，这个$A$的表示就称为<strong>A的谱分解</strong>。</p><h4 id="二次型">二次型</h4><p>$\mathbb{R}^n$上的一个二次型是一个定义在$\mathbb{R}^n$上的函数，它在向量$\mathbf{x}$处的值为可由表达式$\mathbb{Q}(\mathbf{x})=\mathbf{x}^TAx$给出。$A$是一个$n\times n$对称矩阵，称为<strong>关于二次型的矩阵</strong>。</p><p><strong>二次型的变量代换</strong>：如果$\mathbf{x}$表示$\mathbb{R}^n$中的一个向量，那么<strong>变量代换</strong>是如下的形式：</p><p>$$<br>\mathbf{x}=P\mathbf{y} \quad or \quad \mathbf{x}=P^{-1}\mathbf{y}<br>$$</p><p>其中$P$是一个$n\times n$的可逆矩阵。<br>于是对于二次型$\mathbf{x}^TA\mathbf{x}$，有：</p><p>$$<br>\mathbf{x}^TA\mathbf{x}=(P\mathbf{y})^T A (P\mathbf{y}) = \mathbf{y}^T A P^T P \mathbf{y} = \mathbf{y}^T (P^T A P) \mathbf{y}<br>$$</p><p>新的二次型矩阵变为$P^T A P$。因为$A$是对称矩阵，于是存在正交矩阵$P$使得$P^T A P$是角矩阵$D$,于是新的二次型变为$\mathbf{y}^T D \mathbf{y}$。</p><p><strong>主轴定理</strong>：设$A$是一个$n\times n$对称矩阵，那么存在一个正交变量代换$\mathbf{x}=P\mathbf{y}$，它将二次型$\mathbf{x}^TA\mathbf{x}$变为不含交叉乘积项的二次型$\mathbf{y}^T D \mathbf{y}$。<br>定理中的矩阵$P$的列称为二次型$\mathbf{x}^TA\mathbf{x}$的<strong>主轴</strong>，向量$\mathbf{y}$是向量$\mathbf{x}$的在这些主轴构造的$\mathbb{R}^n$中的单位正交基下的坐标向量。</p><p><strong>二次型的分类</strong>：<br>一个二次型$Q$是：</p><ol><li><strong>正定的</strong>,如果对所有$\mathbf{x}\neq\mathbf{0}$，有$Q(\mathbf{x})&gt;0$。</li><li><strong>负定的</strong>,如果对所有$\mathbf{x}\neq\mathbf{0}$，有$Q(\mathbf{x})&lt;0$。</li><li><strong>不定的</strong>，如果$Q(\mathbf{x})$既有正值也有负值。<br>此外，$Q$被称为<strong>半正定的</strong>，如果对所有$\mathbf{x}$，有$Q(\mathbf{x})\geq 0$；被称为<strong>半负定的</strong>，如果对所有$\mathbf{x}$，有$Q(\mathbf{x})\leq 0$。</li></ol><p><strong>定理3</strong>：设$A$是一个$n\times n$对称矩阵，那么一个二次型$\mathbf{x}^TA\mathbf{x}$是:</p><ol><li><strong>正定的</strong>,当且仅当$A$的所有特征值都是正的。</li><li><strong>负定的</strong>,当且仅当$A$的所有特征值都是负的。</li><li><strong>不定的</strong>,当且仅当$A$有正的和负的特征值。</li></ol><p>对任何对称矩阵$A$,在$\Vert\mathbf{x}\Vert =1$的条件下，$\mathbf{x}^TA\mathbf{x}$所有可能值的集合是实轴上的闭区间。分别用$m$和$M$表示区间的左端点和右端点，即：</p><p>$$<br>m=min{\mathbf{x}^TA\mathbf{x}:\Vert\mathbf{x}\Vert=1} \quad and \quad M=max{\mathbf{x}^TA\mathbf{x}: \Vert\mathbf{x}\Vert=1}<br>$$</p><p><strong>定理4</strong>：设$A$是一个$n\times n$对称矩阵，那么有$M$是$A$的最大特征值$\lambda_1$，$m$是$A$的最小特征值。如果$\mathbf{x}$是对应于$M$的单位特征向量$\mathbf{u}_1$，那么$\mathbf{x}^TA\mathbf{x}$的值等于$M$。如果$\mathbf{x}$是对应于$m$的单位特征向量，那么$\mathbf{x}^TA\mathbf{x}$的值等于$m$。</p><p><strong>定理5</strong>：设$A$是一个$n\times n$对称矩阵，在条件：</p><p>$$<br>\mathbf{x}^T\mathbf{x}=1 \quad \mathbf{x}^T \mathbf{u}_1=0<br>$$</p><p>$\mathbf{x}^TA\mathbf{x}$的最大值是<strong>第二大</strong>特征值$\lambda_2$，这个最大值可以在$\mathbf{x}$对应于$\lambda_2$的特征向量$\mathbf{u}_2$的条件下得到。</p><p><strong>定理6</strong>：设$A$是一个$n\times n$对称矩阵，其可正交对角化为$PDP^{-1}$，,将对角矩阵$D$的对角元素重新排列，使得$\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_n$，那么$P$的列是其对应的单位特征向量${\mathbf{u}_1,\mathbf{u}_2,\cdots,\mathbf{u}_n}$。那么对$k=2,3,\cdots,n$，在以下条件的的限制下：</p><p>$$<br>\mathbf{x}^T\mathbf{x}=1,\quad \mathbf{x}^T\mathbf{u}_1=0,\quad\cdots \quad \mathbf{x}^T\mathbf{u}_k=0<br>$$</p><p>$\mathbf{x}^TA\mathbf{x}$的最大值是$\lambda_k$，这个最大值可以在$\mathbf{x}$等于$\lambda_k$的特征向量$\mathbf{u}_k$的条件下得到。</p><h4 id="奇异值分解">奇异值分解</h4><p>并非所有的矩阵都能分解为$A=PDP^{-1}$,且$D$是对角的，但分解$A=QDP^{-1}$对于任意$m\times n$的矩阵$A$都是可能的，此类分解称为<strong>奇异值分解</strong>。</p><p>令$A$为$m\times n$矩阵，那么$A^TA$是对称矩阵且可以正交对角化。令${\mathbf{v}_1,\mathbf{v}_2,\cdots,\mathbf{v}_n}$是$\mathbb{R}^n$中的单位正交基且构成$A^TA$的特征向量，$\lambda_1 ,\lambda_2,\cdots,\lambda_n$是$A^TA$的特征值。那么对于$1\leq i\leq n$，有：</p><p>$$<br>\Vert A\mathbf{v}_i \Vert^2=(A\mathbf{v}_i)^T A\mathbf{v}_i=\mathbf{v}_i^T A^TA\mathbf{v}_i\<br>=\mathbf{v}_i^T (\lambda_i \mathbf{v}_i)\<br>=\lambda_i<br>$$</p><p>所以$A^TA$的特征值都非负，假设所有的特征值重新排列为满足：</p><p>$$<br>\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_n<br>$$</p><p>则$A$的奇异值就是$A^TA$的特征值的平方根，记作$\sigma_1,\sigma_2,\cdots,\sigma_n$递减排列。<strong>$A$的奇异值就是向量$A\mathbf{v}_1,\mathbf{v}_2,\cdots,\mathbf{v}_n$的长度</strong>。</p><p><strong>定理7</strong>：假若${\mathbf{v}_1,\mathbf{v}_2,\cdots,\mathbf{v}_n}$是包含$A^TA$的特征向量的$\mathbb{R}^n$中的单位正交基，重新整理使得对应的特征值满足$\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_n$.假若$A$有r个非零奇异值，那么${A\mathbf{v}_1,A\mathbf{v}_2,\cdots,A\mathbf{v}_n}$是$ColA$的一个正交基，且$rank A = r$.</p><p>矩阵$A$的分解涉及到一个$m\times n$的“对角”矩阵$\Sigma$,其形式为：</p><p>$$<br>\Sigma = \begin{bmatrix}<br>D &amp; 0 \<br>0 &amp; 0<br>\end{bmatrix}<br>$$</p><p>其中$D$是一个$r\times r$的对角矩阵，且r不超过m和n中的较小值。（如果r=m或r=n或都相等，则$M$中不会出现零矩阵。）</p><p><strong>定理8</strong>：设$A$是一个秩为r的$m\times n$矩阵，那么存在一个$m\times r$矩阵$\Sigma$其中$D$的对角元素是$A$的前r个奇异值,$\sigma_1\geq \sigma_2\geq \cdots \geq \sigma_r &gt; 0$,并且存在一个$m\times m$的正交矩阵$U$和一个$n\times n$的正交矩阵$V$，满足：</p><p>$$<br>A = U\Sigma V^T<br>$$</p><p>这样一个分解中的$U$的列称为$A$的<strong>左奇异向量</strong>，而$V$的列称为$A$的<strong>右奇异向量</strong>。</p><p><strong>可逆矩阵定理</strong>：<br>设$A$是一个$n\times n$矩阵，那么下述命题中每一个都与$A$是可逆矩阵等价：</p><ol><li>$(Col A)^\perp = {\mathbf{0}}$</li><li>$(Nul A)^\perp = \mathbb{R}^n$</li><li>$Row A = \mathbb{R}^n$</li><li>$A$有n个非零的奇异值</li></ol><h5 id="伪逆">伪逆</h5><p>取$r=rank A$,那么将$U$和$V$矩阵分块为第一块包含r列的子矩阵，于是有。</p><p>$$<br>A=[U_r \quad U_{m-r}]\begin{bmatrix}<br>D &amp; 0 \<br>0 &amp; 0<br>\end{bmatrix}\begin{bmatrix}<br>V_r^T \<br>V_{n-r}^T<br>\end{bmatrix}=U_rD V_r^T<br>$$</p><p>称为$A$的<strong>简化奇异值分解</strong>，由于$D$的对角线元素非零，因此$D$是可逆矩阵。<br>矩阵$A$的伪逆为：</p><p>$$<br>A^+ = V_rD^{-1}U_r^T<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Grafana Loki 介绍和使用</title>
    <link href="/2025/10/03/loki/"/>
    <url>/2025/10/03/loki/</url>
    
    <content type="html"><![CDATA[<h1>Grafana Loki 介绍和使用</h1><h2 id="Grafana">Grafana</h2><p>Grafana 是一个开源的可视化和监控工具，广泛用于分析和展示时间序列数据（如系统性能指标、应用程序日志和业务数据）。它提供了强大的数据可视化功能，支持多种数据源，并能够通过动态仪表板展示各种实时监控信息。Grafana 常用于运维监控、DevOps、IoT、云计算等领域。</p><h3 id="特性">特性</h3><p>Grafana 能与多种不同类型的数据源集成，包括 Prometheus、InfluxDB、Elasticsearch、MySQL、PostgreSQL、Graphite 等。这意味着用户可以采集不同的数据存储在不同的数据库中，并且能够通过grafana将其集成在一起共同展示。<strong>每种数据源都有独特的查询语言，Grafana 提供灵活的查询编辑器来帮助用户构建查询语句，适配不同的数据源。</strong></p><p>Grafana 提供了可高度定制化的 仪表板（Dashboard），用户可以通过多种可视化组件（如折线图、柱状图、热力图、表格等）来显示数据。仪表板支持动态交互，如缩放、过滤、实时刷新等，便于监控时间序列数据的变化。仪表板可以共享或通过 API 自动生成，方便团队协作和自动化管理。</p><p>Grafana 具备 告警功能，允许用户设定告警规则。当监控的某些指标超过预设阈值时，Grafana 可以通过电子邮件、Slack、PagerDuty 等方式发送通知。告警系统与仪表板集成，可以直接在图表上显示告警状态，帮助用户快速发现异常。</p><p>Grafana 提供细粒度的用户权限管理，支持多租户系统。你可以为不同用户或团队分配不同的访问权限，限制他们对仪表板和数据源的访问。支持与外部身份验证系统集成（如 OAuth、LDAP），简化用户管理。</p><p>Grafana 拥有丰富的插件生态，用户可以通过插件扩展其功能，如添加新的数据源、可视化组件或面板。官方插件库和社区插件库中有大量免费的插件可供使用。支持 JSON 和 CSV 等格式的数据，可以通过插件导入或导出数据。</p><h2 id="kubernetes">kubernetes</h2><p>Kubernetes（简称 K8s）是一个开源的容器编排平台，用于自动化应用容器的部署、扩展和管理。Kubernetes 的核心目标是帮助用户管理和调度大量容器化应用，使应用能够在多个机器或云环境中平稳运行。</p><p><strong>Kubernetes 的核心概念：</strong></p><ul><li><strong>节点（Node）</strong>：Kubernetes 集群中的每台物理或虚拟机，称为节点。每个节点都运行容器化的应用，并由集群中的主节点（Master）进行管理。</li><li><strong>Pod</strong>：Kubernetes 中最小的部署单元，一个 Pod 是一组紧密耦合的容器，通常运行在同一台主机上，共享网络和存储。</li><li><strong>Service</strong>：Kubernetes 中的 Service 是一种抽象层，用于将一组 Pod 的网络服务暴露给其他应用或用户，无论这些 Pod 是否被销毁或重建。</li><li><strong>Deployment</strong>：Deployment 是定义和管理应用的声明性配置，Kubernetes 会根据 Deployment 设定的规则自动确保应用的状态与期望一致（如应用的副本数量、版本升级等）。</li><li><strong>Namespace</strong>：Namespace 用于对集群内的资源进行分组，使不同的团队或项目能够共享同一个 Kubernetes 集群而不会产生冲突。</li><li><strong>ConfigMap 和 Secret</strong>：ConfigMap 用于存储应用的非敏感配置信息，Secret 则用于存储敏感数据（如密码、API 密钥等），并可以安全地提供给 Pod。</li><li><strong>Volumes</strong>：用于持久化存储，Kubernetes 支持将外部存储（如 NFS、云存储）挂载到 Pod 中的容器。</li></ul><p>另一方面，Pod 是 Kubernetes 中的基本计算单元，而服务器集群（即 Kubernetes 集群）是一个管理这些 Pod 的基础设施环境。它们的关系如下：</p><ol><li><p>Kubernetes 集群：</p><p>•服务器集群 是 Kubernetes 运行 Pod 的物理或虚拟服务器的集合。在 Kubernetes 中，这些服务器被称为 节点（Nodes）。<br>•一个 Kubernetes 集群包含多个节点，每个节点都是一台物理机或虚拟机，负责运行 Pod，并执行调度、网络和存储任务。</p></li><li><p>节点 (Node)：</p><p>•每个节点都包含一个 Kubelet（负责与 Kubernetes 控制面板通信的代理），以及一个容器运行时（如 Docker 或 containerd），用于实际执行 Pod 内的容器。<br>•节点的主要作用是为 Pod 提供计算资源，包括 CPU、内存、网络和存储等。</p></li><li><p>Pod 的调度与运行：</p><p>•当在 Kubernetes 中创建一个 Pod 时，Kubernetes 控制面板（Control Plane） 会将 Pod 调度到集群中的某个节点上运行。<br>•调度过程会根据集群中节点的资源使用情况和调度策略，自动选择一个最合适的节点来运行 Pod。<br>•一旦 Pod 被分配到某个节点，节点中的容器运行时会启动 Pod 中的容器，并为其分配资源。</p></li><li><p>Pod 与服务器集群的关系：</p><p>•Pod 是运行在集群节点上的逻辑单元。一个 Pod 必须运行在某个具体的节点（即服务器）上。<br>•集群管理多个 Pod 的分布和状态。Kubernetes 确保 Pod 在集群中能够均匀分布，充分利用节点资源，并且会根据需要（例如节点故障或负载变化）动态调度和重新启动 Pod。<br>•Pod 是集群的工作负载。在集群中，Pod 代表应用或服务的实例，它们运行在节点上，集群负责管理这些 Pod 的生命周期、可用性和扩展。</p></li></ol><h2 id="loki">loki</h2><p>Grafana Loki 是一组开源组件，可以组合成功能齐全的日志记录堆栈。小索引和高度压缩块的设计简化了操作并显着降低了 Loki 的成本。与其他日志系统不同，Loki 的构建理念是仅对有关日志标签的元数据进行索引（就像 Prometheus 标签一样）。然后，日志数据本身会被压缩并以块的形式存储在 Amazon Simple Storage Service (S3) 或 Google Cloud Storage (GCS) 等对象存储中，甚至存储在本地文件系统上。</p><p>Loki 是由 Grafana Labs 开发的、针对 Kubernetes 环境优化的日志聚合系统，但它可以运行在多种不同的环境中。</p><p><strong>Kubernetes 是 Loki 最常用的部署环境。Loki 可以与 Prometheus 和 Grafana 无缝集成，监控 Kubernetes 集群中的容器日志。Loki 在 Kubernetes 中通过 Helm Chart 进行部署，通常与 Promtail（日志收集器）一起使用，用于抓取 Pod 的日志。</strong></p><h3 id="使用流程">使用流程</h3><p><img src="/img/pics//Loki/workflow.png" alt="workflow"></p><ul><li><p>一般会使用 Helm Chart，以简单可扩展模式在 Kubernetes 上安装 Loki。</p></li><li><p>接下来部署 Grafana 代理以从您的应用程序收集日志。</p><ul><li>在 Kubernetes 上，使用 Helm Chart部署 Grafana 代理。配置 Grafana Agent 以从 Kubernetes 集群中抓取日志，并添加 Loki 端点详细信息。</li><li>为日志添加标签。例如添加描述日志来源的标签（区域、集群、环境等）。</li></ul></li><li><p>然后部署 Grafana 或 Grafana Cloud 并配置 Loki 数据源。</p></li><li><p>最后在 Grafana 主菜单中选择“Explore”功能。</p><ul><li>选择一个时间范围。</li><li>选择 Loki 数据源。</li><li>在查询编辑器中使用 LogQL，使用生成器视图探索标签，或使用“启动查询”按钮从示例预配置查询中进行选择。</li></ul></li></ul><p><strong>tips:</strong> 日志流是一组共享相同标签的日志。标签可帮助 Loki 在数据存储中查找日志流，因此拥有一组高质量的标签是高效执行查询的关键。</p><h3 id="实际例子">实际例子</h3><p>如果想试验 Loki，官方提供了一个dockerfile,可以使用 Loki 附带的 Docker Compose 文件在本地运行 Loki。它以整体部署模式运行 Loki，并包含一个用于生成日志的示例应用程序。</p><p><img src="/img/pics//Loki/get-started-flog-v3.png" alt="get_started"><br>Docker Compose 配置运行以下组件，每个组件都在自己的容器中：</p><ul><li><p>flog：生成日志行。 flog 是常见日志格式的日志生成器。</p></li><li><p>Grafana Alloy：从 flog 上刮削flog，然后通过网关将它们推送给 Loki。</p></li><li><p>网关 (nginx)，接收请求并根据请求的 URL 将它们重定向到适当的容器。</p></li><li><p>Loki 读取组件：运行查询前端和query。</p></li><li><p>Loki 写入组件：运行distributor和接收器。</p></li><li><p>Loki 后端组件：运行 Index Gateway、Compactor、Ruler、Bloom Compactor（实验性）和 Bloom Gateway（实验性）。</p></li><li><p>Minio：Loki 用它来存储索引和块。</p></li><li><p>Grafana：提供 Loki 中captures的日志行的可视化</p></li></ul><p>具体请参考：<a href="https://grafana.com/docs/loki/latest/get-started/quick-start/">quickstart</a></p><h3 id="Details">Details</h3><p>Grafana Loki 有两种主要的文件类型：索引（index）和块（chunks）：</p><ul><li>index是在哪里查找特定标签集的日志的目录。</li><li>chunks是一组特定标签的日志条目的容器。</li></ul><p><img src="/img/pics//Loki/chunks_diagram.png" alt="chunks_diagram"></p><p><strong>Index format</strong><br>目前支持两种索引格式作为带有index shipper的单个存储格式：</p><ul><li><p>TSDB（推荐）<br>时间序列数据库（或简称 TSDB）是最初由 Prometheus 维护者为时间序列（度量）数据开发的索引格式。它是可扩展的，并且比已弃用的 BoltDB 索引具有许多优点。 Loki 中的新存储功能仅在使用 TSDB 时可用。</p></li><li><p>Bolt 是用 Go 编写的低级事务性键值存储。</p></li></ul><p><strong>Chunks format</strong><br>块是特定时间范围的流（唯一的标签集）的日志行的容器。</p><p>下面的 ASCII 图详​​细描述了块格式:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">----------------------------------------------------------------------------</span><br><span class="hljs-code">|                        |                       |                         |</span><br><span class="hljs-code">|     MagicNumber(4b)    |     version(1b)       |      encoding (1b)      |</span><br><span class="hljs-code">|                        |                       |                         |</span><br><span class="hljs-code">----------------------------------------------------------------------------</span><br><span class="hljs-section">|                      #structuredMetadata (uvarint)                       |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|      len(label-1) (uvarint)      |          label-1 (bytes)              |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|      len(label-2) (uvarint)      |          label-2 (bytes)              |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|      len(label-n) (uvarint)      |          label-n (bytes)              |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|                      checksum(from #structuredMetadata)                  |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|           block-1 bytes          |           checksum (4b)               |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|           block-2 bytes          |           checksum (4b)               |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|           block-n bytes          |           checksum (4b)               |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|                           #blocks (uvarint)                              |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">| #entries(uvarint) | mint, maxt (varint)  | offset, len (uvarint)         |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">| #entries(uvarint) | mint, maxt (varint)  | offset, len (uvarint)         |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">| #entries(uvarint) | mint, maxt (varint)  | offset, len (uvarint)         |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">| #entries(uvarint) | mint, maxt (varint)  | offset, len (uvarint)         |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|                          checksum(from #blocks)                          |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">| #structuredMetadata len (uvarint) | #structuredMetadata offset (uvarint) |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br><span class="hljs-section">|     #blocks len (uvarint)         |       #blocks offset (uvarint)       |</span><br><span class="hljs-section">----------------------------------------------------------------------------</span><br></code></pre></td></tr></table></figure><p>其中，</p><pre><code class="hljs">mint 和 maxt 分别描述最小和最大 Unix 纳秒时间戳。StructuredMetadata 部分存储不重复的字符串。它用于存储结构化元数据中的标签名称和标签值。注意，结构化元数据部分中的标签字符串和长度是压缩存储的。</code></pre><p><strong>Block format</strong><br>一个block由一系列条目组成，每个条目都是一个单独的日志行。请注意，块的字节是压缩存储的。以下是未压缩时的形式：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">-----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="hljs-code">|  ts (varint)  |  len (uvarint)  |  log-1 bytes  |  len(from #symbols)  |  #symbols (uvarint)  |  symbol-1 (uvarint)  | symbol-n*2 (uvarint) |</span><br><span class="hljs-code">-----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="hljs-section">|  ts (varint)  |  len (uvarint)  |  log-2 bytes  |  len(from #symbols)  |  #symbols (uvarint)  |  symbol-1 (uvarint)  | symbol-n*2 (uvarint) |</span><br><span class="hljs-section">-----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="hljs-section">|  ts (varint)  |  len (uvarint)  |  log-3 bytes  |  len(from #symbols)  |  #symbols (uvarint)  |  symbol-1 (uvarint)  | symbol-n*2 (uvarint) |</span><br><span class="hljs-section">-----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="hljs-section">|  ts (varint)  |  len (uvarint)  |  log-n bytes  |  len(from #symbols)  |  #symbols (uvarint)  |  symbol-1 (uvarint)  | symbol-n*2 (uvarint) |</span><br><span class="hljs-section">-----------------------------------------------------------------------------------------------------------------------------------------------</span><br></code></pre></td></tr></table></figure><p>ts 是日志的 Unix 纳秒时间戳，而 len 是日志条目的长度（以字节为单位）。符号存储对包含块的structedMetadata中的标签名称和值的实际字符串的引用。</p><h4 id="Write-and-Read">Write and Read</h4><p><strong>写入路径</strong><br>从较高层面来看，Loki 中的写入路径的工作原理如下：</p><ul><li>distributor接收带有流和日志行的 HTTP POST 请求。</li><li>distributor对请求中包含的每个流进行哈希处理，以便它可以根据一致哈希环中的信息确定需要将其发送到的Ingester实例。</li><li>distributor将每个流发送到适当的Ingester及其副本（基于配置的复制因子）。</li><li>Ingester接收带有日志行的流，并为流的数据创建一个块或附加到现有块。每个租户和每个标签集的块都是唯一的。</li><li>Ingester确认写入。</li><li>Distributor等待大多数（法定人数）Ingester确认他们的写入。</li><li>如果distributor至少收到法定数量的已确认写入，则它会以成功响应（2xx 状态代码）。或者在写入操作失败时出现错误（4xx 或 5xx 状态代码）。</li></ul><p><strong>读取路径</strong><br>概括地说，Loki 中的读取路径的工作原理如下：</p><ul><li>查询前端接收带有 LogQL 查询的 HTTP GET 请求。</li><li>查询前端将查询拆分为子查询并将它们传递给查询调度程序。</li><li>query从调度器中提取子查询。</li><li>query将查询传递给内存数据的所有Ingester。</li><li>Ingester返回与查询匹配的内存中数据（如果有）。</li><li>如果Ingester未返回数据或返回的数据不足，则query会延迟从后备存储加载数据并对其运行查询。</li><li>query迭代所有接收到的数据并进行重复数据删除，将子查询的结果返回到查询前端。</li><li>查询前端等待查询的所有子查询完成并由query返回。</li><li>查询前端将各个结果合并为最终结果并将其返回给客户端。</li></ul><p><strong>Distributor</strong>:<br>Distributor Service负责处理来自客户端的传入推送请求。这是日志数据写入路径的第一步。一旦Distributor收到 HTTP 请求中的一组流，就会验证每个流的正确性并确保其在配置的租户（或全局）限制内。然后，每个有效流会并行发送到 n 个Ingester，其中 n 是数据的replication factor。Distributor使用一致性哈希来确定将流发送到的接收器。</p><p><strong>Ingester</strong>:<br>Ingester Service 负责持久化数据并将其传送到写入路径上的长期存储（Amazon Simple Storage Service、Google Cloud Storage、Azure Blob Storage 等），并返回最近摄取的in-memory日志数据以供查询在读取路径上。</p><p>Ingesters 包含一个生命周期管理器，用于管理哈希环中 Ingesters 的生命周期。每个摄取器的状态为 PENDING、JOINING、ACTIVE、LEAVING 或 UNHEALTHY：</p><pre><code class="hljs">- PENDING 是 Ingester 等待另一个正在LEAVING的 Ingester 进行切换时的状态。- JOINING 是 Ingester 当前将其令牌插入环并初始化自身时的状态。它可能会接收对其拥有的令牌的写入请求。- ACTIVE 是 Ingester 完全初始化时的状态。它可以接收对其拥有的令牌的写入和读取请求。- LEAVING 是 Ingester 关闭时的状态。它可能会接收对其内存中仍具有的数据的读取请求。- UNHEALTHY 是 Ingester 心跳失败时的状态。 UNHEALTHY 由distributor在定期检查环时设置。</code></pre><p>Ingester接收到的每个日志流都会在内存中构建成一组许多“块”，并以可配置的时间间隔刷新到后备存储后端。</p><p>如果Ingester进程崩溃或突然退出，所有尚未刷新的数据都将丢失。 Loki 通常配置为复制每个日志的多个副本（通常是 3 个）以减轻这种风险。</p><p>当持久存储提供者发生刷新时，块会根据其租户、标签和内容进行哈希处理。这意味着具有相同数据副本的多个摄取器不会将相同的数据写入后备存储两次，但如果其中一个副本的任何写入失败，则将在后备存储中创建多个不同的块对象。请参阅查询器了解如何进行重复数据删除。</p><p><strong>Replication factor</strong><br>为了减少在任何单个Ingester上丢失数据的可能性，distributor会将写入数据转发给其中的复制因子。通常，复制因子为 3。复制允许Ingester重新启动和退出，而不会导致写入失败，并在某些情况下增加了防止数据丢失的额外保护。</p><p>从广义上讲，对于推送给disttibutor的每个标签集（称为流），Distributor都会对标签进行散列处理，并使用得到的值在环中查找复制因子Ingester（这是一个公开分布式散列表的子组件）。然后，它会尝试把相同的数据写入到所有的接收器中。如果成功写入的数据少于quorum，就会产生错误。quorum的定义是 floor( replication_factor / 2 ) + 1。因此，对于我们的复制因子 3，我们要求有两次写入成功。如果成功写入的次数少于两次，分发器就会返回错误，写入操作将被重试。</p><p><strong>Hashing</strong>:<br>distributor使用一致的哈希算法和可配置的复制因子来确定哪些Ingester服务实例应接收给定的数据流。</p><p>数据流是一组与租户和唯一标签集相关联的日志。使用租户 ID 和标签集对数据流进行散列，然后使用散列找到要将数据流发送给的Ingester。</p><p>哈希环通过使用成员列表协议的点对点通信进行维护，或存储在密钥-值存储（如 Consul）中，用于实现一致的哈希；所有Ingester都用自己拥有的一组令牌将自己注册到哈希环中。每个令牌都是一个随机的无符号 32 位数。除了一组令牌，Ingester还会将自己的状态注册到哈希环中。状态 “JOINING ”和 “ACTIVE ”都会收到写入请求，而 “ACTIVE ”和 “LEAVING ”则会收到读取请求。在进行哈希查找时，Distributor只使用处于相应状态的Ingester的令牌。</p><p>要进行哈希值查询，Distributor要找到其值大于流哈希值的最小适当标记。当复制因子大于 1 时，属于不同Ingester的下一个令牌（顺时针环形）也将包含在结果中。</p><p>这种哈希值设置的效果是，Ingester拥有的每个标记都负责一定范围的哈希值。如果存在值为 0、25 和 50 的三个令牌，则将向拥有令牌 25 的Ingester提供哈希值 3；拥有令牌 25 的摄取者负责 1-25 的哈希范围。</p><h2 id="Log-queries">Log queries</h2><p>所有 LogQL 查询都包含日志流选择器。</p><p><img src="/img/pics//Loki/query_components.png" alt="log query"></p><p>日志流选择器后面可以跟一个日志pipeline。日志pipeline是一组链接在一起并应用于所选日志流的阶段表达式。每个表达式都可以过滤、解析或改变日志行及其各自的标签。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&#123;<span class="hljs-built_in">container</span>=<span class="hljs-string">&quot;query-frontend&quot;</span>,<span class="hljs-keyword">namespace</span>=<span class="hljs-string">&quot;loki-dev&quot;</span>&#125; |= <span class="hljs-string">&quot;metrics.go&quot;</span> | logfmt | duration &gt; <span class="hljs-number">10</span>s and throughput_mb &lt; <span class="hljs-number">500</span><br></code></pre></td></tr></table></figure><p>例如，该查询由以下部分组成：</p><ul><li><p>日志流选择器 <code>&#123;container=&quot;query-frontend&quot;,namespace=&quot;loki-dev&quot;&#125;</code> ，其目标是 loki-dev 命名空间中的 query-frontend 容器。</p></li><li><p>日志pipeline <code>|= &quot;metrics.go&quot; |logfmt |duration &gt; 10s and throughput_mb &lt; 500</code>，这将过滤掉包含单词metrics.go的日志，然后解析每个日志行以提取更多标签并使用它们进行过滤。</p><p>为了避免转义特殊字符，在引用字符串时可以使用 <code>(反引号) 而不是 &quot;。例如，</code>\w+` 与 “\w+” 相同。这在编写包含多个反斜杠的正则表达式时特别有用。</p></li></ul><h3 id="log-selector">log selector</h3><p>日志流选择器确定查询结果中包含哪些日志流。日志流是日志内容的唯一来源，例如文件。然后，更细粒度的日志流选择器将搜索流的数量减少到可管理的数量。这意味着传递给日志流选择器的标签将影响查询执行的相对性能。</p><p>日志流选择器由一个或多个以逗号分隔的键值对指定。每个键都是一个日志标签，每个值都是该标签的值。大括号（{ 和 }）分隔流选择器。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&#123;app=&quot;mysql&quot;,<span class="hljs-type">name</span>=&quot;mysql-backup&quot;&#125;<br></code></pre></td></tr></table></figure><p>所有标签为 app 且值为 mysql ,标签为 name 且值为 mysql-backup 的日志流都将包含在查询结果中。流可能包含其他标签和值对，但只有流选择器中指定的对用于确定查询结果中将包含哪些流。</p><p>适用于 Prometheus 标签选择器的相同规则也适用于 Grafana Loki 日志流选择器。标签名称后面的 = 运算符是标签匹配运算符。支持以下标签匹配运算符：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">=：完全相等<br>!=<span class="hljs-symbol">:</span> 不等于<br>=~<span class="hljs-symbol">:</span> 正则表达式匹配<br>!~<span class="hljs-symbol">:</span> 正则表达式不匹配<br>正则表达式日志流示例：<br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;名称=~“mysql.+”&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;名称！~“mysql.+”&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;名称！~ `mysql-\d+`&#125;</span><br></code></pre></td></tr></table></figure><p>注意：与行过滤器正则表达式不同，=~ 和 !~ 正则表达式运算符是完全锚定的。这意味着正则表达式必须匹配整个字符串，包括换行符。正则表达式 .默认情况下，字符不匹配换行符。如果您希望正则表达式点字符匹配换行符，您可以使用单行标志，如下所示： <code>(?s)search_term.+ </code>匹配 <code>search_term\n</code>。或者，您可以将<code> \s</code>（匹配空格，包括换行符）与 <code>\S</code>（匹配非空格字符）结合使用来匹配所有字符，包括换行符。</p><p>正则表达式日志流换行符：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx">&#123;<span class="hljs-attribute">name</span> =<span class="hljs-regexp">~ &quot;.*mysql.*&quot;&#125;:</span> 与带有换行符的日志标签值不匹配<br>&#123;<span class="hljs-attribute">name</span> =<span class="hljs-regexp">~ &quot;(?s).*mysql.*&#125;：将日志标签值与换行符匹配</span><br>&#123;<span class="hljs-attribute">name</span> =<span class="hljs-regexp">~ &quot;[\S\s]*mysql[\S\s]*&#125;：将日志标签值与换行符匹配</span><br></code></pre></td></tr></table></figure><h3 id="log-pipeline">log pipeline</h3><p>日志pipeline可以附加到日志流选择器以进一步处理和过滤日志流。它由一组表达式组成。对于每个日志行，每个表达式都按从左到右的顺序执行。如果表达式过滤掉日志行，pipeline将停止处理当前日志行并开始处理下一个日志行。</p><p>某些表达式可以改变日志内容和相应的标签，然后可用于后续表达式中的进一步过滤和处理。例如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">| line_format &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.status_code</span>&#125;&#125;</span><span class="language-xml">&quot;</span><br></code></pre></td></tr></table></figure><p>日志pipeline表达式属于以下四类之一：</p><ul><li>过滤表达式：行过滤表达式和标签过滤表达式</li><li>解析表达式</li><li>格式化表达式：行格式表达式和标签格式表达式</li><li>标签表达式：删除标签表达式并保留标签表达式</li></ul><h4 id="line-filter-expression">line filter expression</h4><p>line filter expression对来自匹配日志流的聚合日志执行分布式 <code>grep</code>。它搜索日志行的内容，丢弃那些与区分大小写的表达式不匹配的行。</p><p>每个line filter expression都有一个过滤运算符，后跟文本或正则表达式。支持这些过滤器运算符：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|=：日志行包含字符串</span><br>!<span class="hljs-punctuation">=</span><span class="hljs-punctuation">:</span> 日志行不包含字符串<br><span class="hljs-string">|~：日志行包含正则表达式的匹配项</span><br>!<span class="hljs-symbol">~</span>: 日志行不包含正则表达式的匹配项<br></code></pre></td></tr></table></figure><p>注意：与标签匹配器正则表达式运算符不同，<code>|~ </code>和 <code>!~</code> 正则表达式运算符不是完全锚定的。这意味着 <code>.</code>正则表达式字符匹配所有字符，包括换行符。</p><p>例子：<br>保留包含子字符串“error”的日志行：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|=“error”</span><br></code></pre></td></tr></table></figure><p>使用此示例的完整查询：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;<span class="hljs-attribute">job</span>=“mysql”&#125; |=“error”<br></code></pre></td></tr></table></figure><p>丢弃具有子字符串“kafka.server:type=ReplicaManager”的日志行：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">!= <span class="hljs-string">&quot;kafka.server:type=ReplicaManager&quot;</span><br></code></pre></td></tr></table></figure><p>使用此示例的完整查询：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;<span class="hljs-attribute">instance</span>=~&quot;kafka-[23]<span class="hljs-string">&quot;,name=&quot;</span>kafka<span class="hljs-string">&quot;&#125; != &quot;</span>kafka.server:<span class="hljs-attribute">type</span>=ReplicaManager&quot;<br></code></pre></td></tr></table></figure><p>保留包含以 tsdb-ops 开头并以 io:2003 结尾的子字符串的日志行。使用正则表达式的完整查询：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;name<span class="hljs-punctuation">=</span><span class="hljs-string">&quot;kafka&quot;</span>&#125; <span class="hljs-string">|~ &quot;</span>tsdb<span class="hljs-punctuation">-</span>ops.*io<span class="hljs-punctuation">:</span><span class="hljs-number">2003</span><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>保留包含以 error= 开头且后跟 1 个或多个单词字符的子字符串的日志行。使用正则表达式的完整查询：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;cassandra&quot;</span>&#125; |~ `<span class="hljs-attribute">error</span>=\w+`<br></code></pre></td></tr></table></figure><h4 id="label-filter-expression">label filter expression</h4><p>标签过滤表达式允许使用原始标签和提取的标签来过滤日志行。它可以包含多个谓词。</p><p>谓词包含标签标识符、操作和用于与标签进行比较的值。</p><p>例如，对于 <code>cluster=&quot;namespace&quot;</code>，cluster是标签标识符，操作是=，值为“namespace”。<strong>标签标识符始终位于操作的左侧。</strong></p><p>loki支持从查询输入自动推断出的多种值类型</p><ul><li><strong>String</strong>使用双引号或反引号，例如“200”或“us-central1”。</li><li><strong>Duration</strong>是十进制数字序列，每个数字都有可选的分数和单位后缀，例如“300ms”、“1.5h”或“2h45m”。有效的时间单位为“ns”、“us”（或“μs”）、“ms”、“s”、“m”、“h”。</li><li><strong>Number</strong> 为浮点数（64 位），如 250、89.923。</li><li><strong>Byte</strong>是十进制数字序列，每个数字都有可选的分数和单位后缀，例如“42MB”、“1.5Kib”或“20b”。有效字节单位为“b”、“kib”、“kb”、“mib”、“mb”、“gib”、“gb”、“tib”、“tb”、“pib”、“pb”、“eib” ”，“eb”。</li></ul><p>使用duration、number和byte将在比较之前转换标签值并支持以下比较器：</p><ul><li><code>==</code> 或<code> =</code> 表示相等。</li><li><code>!=</code> 表示不等式。</li><li><code>&gt; </code>和 <code>&gt;=</code> 表示大于和大于或等于。</li><li><code>&lt; </code>和 <code>&lt;= </code>表示小于和小于或等于。<br>例如，<code>logfmt |duration &gt; 1m</code> 且 <code>bytes_consumed &gt; 20MB</code></li></ul><p>如果标签值转换失败，则不会过滤日志行并添加 __error__ 标签。可以使用 and 和 or 链接多个谓词，它们分别表示 and 和 or 二元运算。并且可以用逗号、空格或其他pipeline等效地表示。标签过滤器可以放置在log pipeline中的任何位置。</p><p>这意味着以下所有表达式都是等效的:</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">| duration &gt;= <span class="hljs-number">20</span>ms <span class="hljs-keyword">or</span> size == <span class="hljs-number">20</span>kb <span class="hljs-keyword">and</span> <span class="hljs-keyword">method!</span>~<span class="hljs-string">&quot;2..&quot;</span><br>| duration &gt;= <span class="hljs-number">20</span>ms <span class="hljs-keyword">or</span> size == <span class="hljs-number">20</span>kb | <span class="hljs-keyword">method!</span>~<span class="hljs-string">&quot;2..&quot;</span><br>| duration &gt;= <span class="hljs-number">20</span>ms <span class="hljs-keyword">or</span> size == <span class="hljs-number">20</span>kb , <span class="hljs-keyword">method!</span>~<span class="hljs-string">&quot;2..&quot;</span><br>| duration &gt;= <span class="hljs-number">20</span>ms <span class="hljs-keyword">or</span> size == <span class="hljs-number">20</span>kb  <span class="hljs-keyword">method!</span>~<span class="hljs-string">&quot;2..&quot;</span><br></code></pre></td></tr></table></figure><p>多个谓词求值的优先级是从左到右。可以用括号将谓词括起来以强制使用不同的优先级。</p><p>这些示例是等效的：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">| duration &gt;= 20ms or method=<span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span> and size &lt;= 20KB<br>| ((duration &gt;= 20ms or method=<span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span>) and size &lt;= 20KB)<br></code></pre></td></tr></table></figure><h3 id="Parser-expression">Parser expression</h3><p>解析器表达式可以从日志内容中解析并提取标签。然后，这些提取的标签可用于使用标签过滤器表达式进行过滤或用于度量聚合。</p><p>提取的标签键会被所有解析器自动清理，以遵循 Prometheus 指标名称约定。（它们只能包含 ASCII 字母和数字，以及下划线和冒号。它们不能以数字开头。）</p><p>例如，pipeline <code> | json</code> 将生成以下映射：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123; &quot;<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span>&quot;: &#123;c: <span class="hljs-string">&quot;d&quot;</span>&#125;, e: <span class="hljs-string">&quot;f&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p>$\rightarrow$</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;<span class="hljs-attribute">a_b_c</span>=<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-attribute">e</span>=<span class="hljs-string">&quot;f&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>如果出现错误，例如，如果该行不是预期的格式，则日志行不会被过滤，而是会添加一个新的 <strong>error</strong> 标签。</p><p>如果原始日志流中已存在提取的标签键名称，则会在提取的标签键后面加上 <code>_extracted</code> 关键字作为后缀，以区分两个标签。可以使用标签格式化程序表达式强制覆盖原始标签。</p><p>如果可以的话，使用预定义的解析器 json 和 logfmt 会更容易。如果不能，模式和正则表达式解析器可用于具有不寻常结构的日志行。模式解析器编写起来更容易、更快；它的性能也优于正则表达式解析器。单个日志管道可以使用多个解析器。这对于解析复杂的日志很有用。</p><h3 id="Pattern">Pattern</h3><p>模式解析器允许通过定义模式表达式<code>（|pattern “&lt;pattern-expression&gt;”）</code>从日志行中显式提取字段。该表达式与日志行的结构匹配。<br>例如：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">0.191.12.2</span> - - <span class="hljs-string">[10/Jun/2021:09:14:29 +0000]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /api/plugins/versioncheck HTTP/1.1&quot;</span> <span class="hljs-number">200</span> <span class="hljs-number">2</span> <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">&quot;Go-http-client/2.0&quot;</span> <span class="hljs-string">&quot;13.76.247.102, 34.120.177.193&quot;</span> <span class="hljs-string">&quot;TLSv1.2&quot;</span> <span class="hljs-string">&quot;US&quot;</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>该日志行可以用表达式解析</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ip</span>&gt;</span> - - <span class="hljs-tag">&lt;<span class="hljs-name">_</span>&gt;</span>“<span class="hljs-tag">&lt;<span class="hljs-name">method</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">uri</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">_</span>&gt;</span>”<span class="hljs-tag">&lt;<span class="hljs-name">status</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">size</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">_</span>&gt;</span>“<span class="hljs-tag">&lt;<span class="hljs-name">agent</span>&gt;</span>”<span class="hljs-tag">&lt;<span class="hljs-name">_</span>&gt;</span><br></code></pre></td></tr></table></figure><p>提取这些字段：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-string">&quot;ip&quot;</span> <span class="hljs-operator">=</span>&gt; <span class="hljs-string">&quot;0.191.12.2&quot;</span><br><span class="hljs-string">&quot;method&quot;</span> <span class="hljs-operator">=</span>&gt; <span class="hljs-string">&quot;GET&quot;</span><br><span class="hljs-string">&quot;uri&quot;</span> <span class="hljs-operator">=</span>&gt; <span class="hljs-string">&quot;/api/plugins/versioncheck&quot;</span><br><span class="hljs-string">&quot;status&quot;</span> <span class="hljs-operator">=</span>&gt; <span class="hljs-string">&quot;200&quot;</span><br><span class="hljs-string">&quot;size&quot;</span> <span class="hljs-operator">=</span>&gt; <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-string">&quot;agent&quot;</span> <span class="hljs-operator">=</span>&gt; <span class="hljs-string">&quot;Go-http-client/2.0&quot;</span><br></code></pre></td></tr></table></figure><p>pattern expression由captures和literals组成。</p><p>captures是由<code>&lt;</code>和<code>&gt;</code>字符分隔的字段名称。 <example> 定义字段名称<code>example</code>。未命名的captures显示为<code> &lt;_&gt;</code>。未命名的captures会跳过匹配的内容。</p><p>captures从行开头或前一组literals匹配到行结尾或下一组literals。如果captures不匹配，模式解析器将停止。</p><p>literals可以是任意 UTF-8 字符序列，包括空白字符。</p><p>默认情况下，模式表达式锚定在日志行的开头。如果表达式以literals开头，则日志行也必须以同一组literals开头。如果您不想将表达式锚定在开头，请在表达式的开头使用 <code>&lt;_&gt;</code>。</p><p>考虑日志行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">level</span>=debug <span class="hljs-attribute">ts</span>=2021-06-10T09:24:13.472094048Z <span class="hljs-attribute">caller</span>=logging.go:66 <span class="hljs-attribute">traceID</span>=0568b66ad2d9294c <span class="hljs-attribute">msg</span>=<span class="hljs-string">&quot;POST /loki/api/v1/push (204) 16.652862ms&quot;</span><br></code></pre></td></tr></table></figure><p>要匹配 ````msg=```，请使用表达式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">_</span>&gt;</span> msg=&quot;<span class="hljs-tag">&lt;<span class="hljs-name">method</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span> (<span class="hljs-tag">&lt;<span class="hljs-name">status</span>&gt;</span>) <span class="hljs-tag">&lt;<span class="hljs-name">latency</span>&gt;</span>&quot;<br></code></pre></td></tr></table></figure><p>模式表达式在以下情况下无效：</p><ul><li>它不包含任何命名捕获。</li><li>它包含两个连续的捕获，未用空格字符分隔。</li></ul>### line format expression行格式表达式可以使用 文本/模板 格式重写日志行内容。它需要一个字符串参数 ```| line_format "{{.label_name}}"```，这是模板格式。所有标签都被注入变量到模板中，并且可以与 ```{{.label_name}}``` 一起使用。例如下面的表达式：<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">&#123;container=“frontend”&#125;| logfmt | line_format &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.query</span>&#125;&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.duration</span>&#125;&#125;</span><span class="language-xml">&quot;</span><br></code></pre></td></tr></table></figure>将提取并重写日志行以仅包含查询和请求的持续时间。可以在模板中使用双引号字符串或反引号 `{{.label_name}}` 以避免需要转义特殊字符。<figure class="highlight plaintext"><figcaption><span>还支持数学函数。例子：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs line_format```"><br>如果我们有以下标签 ```ip=1.1.1.1```、```status=200``` 和```duration=3000(ms)```，我们可以将持续时间除以 1000 以获得以秒为单位的值。<br><br></code></pre></td></tr></table></figure>{container=“frontend”} |logfmt | line_format "{{.ip}} {{.status}} {{div .duration 1000}}"```上面的查询将为我们提供 ```1.1.1.1 200 3```的行**Tips**:还可以使用 __line__ 函数访问日志行，并使用 __timestamp__ 函数访问时间戳。### label format expression``` | label_format```表达式可以重命名、修改或添加标签。它采用逗号分隔的相等操作列表作为参数，可以同时启用多个操作。当两边都是标签标识符时，例如```dst=src```，该操作会将```src```标签重命名为```dst```。右侧也可以是模板字符串（双引号或反引号），例如 ```dst="{{.status}} {{.query}}"```，在这种情况下，```dst``` 标签值将替换为 文本/模板 评估的结果。这是与```| line_format```相同的模板引擎。这意味着标签可用作变量，并且可以使用相同的函数列表。在这两种情况下，如果目标标签不存在，则会创建一个新标签。重命名形式``` dst=src ```将在将 ```src ```标签重新映射到 ```dst``` 标签后删除它。但是，template format将保留引用的标签，这样 ```dst="{{.src}}" ```会导致``` dst``` 和 ```src``` 具有相同的值。每个表达式中单个标签名称只能出现一次。这意味着  | label_format foo=bar,foo="new"  是不允许的，但您可以使用两个表达式来达到所需的效果： |label_format foo=bar | label_format foo =“new”]]></content>
    
    
    
    <tags>
      
      <tag>Grafana,Loki,数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机过程</title>
    <link href="/2025/10/03/markov/"/>
    <url>/2025/10/03/markov/</url>
    
    <content type="html"><![CDATA[<h1>随机过程</h1><p>定义：随机过程（stochastic process）通常是指随着时间或者空间变化的一组随机变量。随机过程是一组随机变量的集合。集合内的随机变量以时间或空间位置作为索引下标，通常是时间。根据下标是否为连续的又可以分为离散随机过程和连续随机过程。</p><p>例如，离散时间的随机过程可以写作随机变量序列的形式：<br>$$<br>X_0, X_1, X_2, \cdots, X_t,\cdots<br>$$<br>其中，$X_t$为随机变量，下标$t$表示时间。各个时刻的随机变量之间存在着概率关系，这是随机过程的核心。</p><h2 id="马尔可夫性">马尔可夫性</h2><p>马尔可夫随机过程（Markov process）一种特殊的随机过程。这种随机过程为随着时间进行演化的一组随机变量进行建模，并假设系统在当前时刻的状态值只与上一个状态值有关，且与更早的时刻无关，称为无记忆性(memoryless property)。</p><p>我们的目标是求得一个随机变量的联合分布概率，这样就可以依次得到各个随机变量的边际分布。而马尔可夫性质极大地简化了问题求解的计算难度。</p><h3 id="推导">推导</h3><p>对于随机过程中的随机变量序列$X_0, X_1, X_2, \cdots, X_T$，通常情况下各个时刻的随机变量之间存在概率关系。如果只考虑过去的信息，则当前时刻的状态$X_t$与过去的状态均有关系，也就是存在如下条件概率。<br>$$<br>p(X_t|X_{t-1},X_{t-2},\cdots,X_1)<br>$$<br>随机过程的核心是对该条件概率建模，如果考虑过去所有时刻的状态，计算量太大。<strong>因此需要对此条件概率进行简化来降低问题求解的难度，而马尔可夫假设正是这样一种简化</strong>。</p><p>假设随机过程满足马尔可夫性，即：<br>$$<br>p(X_t|X_{t-1},X_{t-2},\cdots,X_1)=p(X_t|X_{t-1})<br>$$<br>则有：<br>$$<br>p(X_t|X_{t-1},X_{t-2},\cdots,X_1)=p(X_t|X_{t-1})<br>$$<br>即系统在当前时刻的状态只与上一时刻的状态有关，与更早的状态无关，这也叫做一阶马尔可夫性。利用随机向量的链式法则，可以直接求得随机变量序列联合概率的一个简洁计算公式:<br>$$\begin{equation}<br>p(X_0,X_1,\cdots,X_T)=p(X_0)p(X_1|X_0)p(X_2|X_1)\cdots p(X_T|X_{T-1})<br>\end{equation}<br>$$<br>其中，$p(X_0)$表示初始状态的概率。(1)式表明，如果一个系统有马尔可夫性，则序列的联合概率由各个条件概率值$p(X_t|X_{t-1})$以及初始概率$p(X_0)$决定。</p><h2 id="马尔可夫链">马尔可夫链</h2><p>根据系统状态(即随机变量)是否连续，时间是否连续，可以将马尔可夫过程分为：</p><table><thead><tr><th></th><th>可数状态空间</th><th>连续状态空间</th></tr></thead><tbody><tr><td><strong>离散时间</strong></td><td>有限或可数状态空间的马尔可夫链</td><td>可测状态空间的马尔可夫链</td></tr><tr><td><strong>连续时间</strong></td><td>连续时间的马尔可夫过程</td><td>具有马尔可夫性的连续型随机过程</td></tr></tbody></table><p>一般研究的是离散时间的马尔可夫链，这种随机过程的取值可以由状态转移概率$p(X_t|X_{t-1})$来描述条件概率。含义也就是系统上一时刻为$X_{t-1}$时，系统下一时刻转移到状态$X_t$的概率。</p><p>如果系统有$m$个状态，则马尔可夫链可以用一个$m\times m$的矩阵$P$来表示，其中$P_{ij}$表示系统从状态$i$转移到状态$j$的概率。<br>$$<br>P=\left[<br>\begin{matrix}<br>p(X_0\rightarrow X_0) &amp; p(X_0\rightarrow X_1) &amp; \cdots &amp; p(X_0\rightarrow X_m) \<br>p(X_1\rightarrow X_0) &amp; p(X_1\rightarrow X_1) &amp; \cdots &amp; p(X_1\rightarrow X_m) \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>p(X_m\rightarrow X_0) &amp; p(X_m\rightarrow X_1) &amp; \cdots &amp; p(X_m\rightarrow X_m)<br>\end{matrix}<br>\right]<br>$$<br>$p_{ij}$表示由状态$i$转移到状态$j$的概率。<br>$$<br>p_{ij}=p(X_t=j|X_{t-1}=i)<br>$$<br>当前时刻的状态无论处于哪一个状态，下一刻必然会转移到$m$中的某一个状态，即有等式约束：<br>$$<br>\sum_{j=1}^{m}p_{ij}=1<br>$$<br>对于状态连续的马尔可夫链，每个时刻各个状态的值由概率密度函数来描述，状态转移概率为条件密度函数。</p><p><strong>时齐马尔可夫性</strong>：如果任何时刻状态转移概率是相同的，则称为时齐马尔可夫链(Time-homogeneous Markov chains)。此时只有一个状态转移矩阵，在各个时刻均适用。</p><h3 id="例子">例子</h3><p>给出某一个时刻的状态$\mathbf{\pi}$为一个行向量，假设状态有$m$个，则向量$\mathbf{\pi}$需要满足：<br>$$<br>\sum_{i=1}^{m}\pi_i=1<br>$$<br>现在，如果令时刻$t$的状态为向量$\mathbf{\pi}<em>t$，则可以根据前一个时刻的状态分布$\mathbf{\pi}</em>{t-1}$，计算出当前时刻的状态分布$\mathbf{\pi}<em>t$。由于状态转移矩阵的第$i$列表示从上一个时刻的各个状态状态转移到当前时刻的状态$i$的概率，根据全概率公式，$t$时刻的状态为$i$的概率为：<br>$$<br>\pi</em>{t,i}=\sum_{j=1}^{m}p_{ij}\pi_{t-1,j}<br>$$<br>于是，对于所有状态，就可以写作矩阵形式为：<br>$$<br>\pi_t=\mathbf{P}\pi_{t-1}<br>$$<br>反复利用该公式就可以得到:<br>$$<br>\pi_t=\pi_{t-1}\mathbf{P}=\pi_{t-1}\mathbf{P}\mathbf{P}=\cdots=\pi_0\mathbf{P}^t<br>$$<br>因此给定初始的状态分布$\pi_0$和状态转移矩阵$\mathbf{P}$，就可以计算出任意时刻的状态概率分布，这里假设是时齐的，不然每一个时刻需要使用不同的状态转移矩阵。</p><p>进一步的，我们可以定义n步转移概率为从状态$i$经过$n$转移到状态$j$的概率。记为：<br>$$<br>p_{ij}^n=p(X_n=j|X_{0}=i)<br>$$<br>以及n步时齐的马尔科夫链的转移矩阵为：<br>$$<br>P^n=\left[<br>\begin{matrix}<br>p_{11}^{(n)} &amp; p_{12}^{(n)} &amp; \cdots &amp; p_{1m}^{(n)} \<br>p_{21}^{(n)} &amp; p_{22}^{(n)} &amp; \cdots &amp; p_{2m}^{(n)} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>p_{m1}^{(n)} &amp; p_{m2}^{(n)} &amp; \cdots &amp; p_{mm}^{(n)}<br>\end{matrix}<br>\right]<br>$$<br>特殊的，如果$n=1$，则就是状态转移矩阵。</p><p>根据定义，$n$步转移概率满足$Chapman-Kolmogorov equations$(简称CK方程)：<br>$$<br>p_{ij}^{(n)}=\sum_{k=1}^{m}p_{ik}^{(l)}p_{kj}^{(n-l)}<br>$$<br>即从状态$i$经过$n$次转移进入状态$j$的概率，等于从状态$i$先经过$l$步转移到状态$k$，再乘以经过$(n-l)$步转移到状态$j$的概率，并对所有的$k$求和。</p><p>根据$C-K$方程，对于$n$步的转移矩阵，有如下的乘积关系：<br>$$<br>\mathbf{P}^{n+l}=\mathbf{P}^{(n)}\mathbf{P}^{(l)}<br>$$<br>由此我们得到$\mathbf{P}^n=\mathbf{P}^{(n)}$</p><h2 id="马尔可夫链状态的性质">马尔可夫链状态的性质</h2><p>实际上，并非每个状态经过转移后都可能会转移到另一个状态，因此我们说如果可以从状态$i$转移到$j$,即存在$n \geq 0$使得<br>$$<br>p_{ij}^{(n)}\gt 0<br>$$<br>则称状态$i$到状态$j$是可达的，记作$i \rightarrow j$. 如果$i \rightarrow j$且$j \rightarrow i$，则称这两个状态是互通的，记为$i \leftrightarrow j$。</p><p><strong>互通具有自反性，对称性，传递性。因此，互通是第一种等价关系。所有互通的状态属于同一个等价类，可以按照互通性将所有状态划分分成若干个不相交的子集。</strong></p><p>根据可约关系，如果一个马尔可夫链任意两个都是互通的，则称它是不可约的（irreducible），否则是可约的。</p><h3 id="周期">周期</h3><p>状态$i$的周期$d(i)$定义为该状态出发，经过n步之后回到该状态，这些n的最大公约数。<br>$$ d(i) = gcd{n&gt;0:p_{ii}^{(n)}&gt;0}$$<br>其中gcd为最大公约数。如果对所有$n \gt 0$都有$p_{ii}^{(n)}\gt 0$，则称周期为无穷大$(+\infty)$。如果状态的周期$d(i)\gt&gt;1$,则称该状态是周期的。如果状态的周期为1，则它为非周期的。</p><ul><li>如果两个状态互通，则它们的周期相同。</li></ul><p><strong>推论</strong></p><ol><li>如果不可约的马尔可夫链有周期性状$i$，则其所有状态为周期性状态</li><li>对于不可约的马尔可夫链，如果一个状态$i$是非周期的，则所有的状态都是非周期的。</li></ol><p>令$f_{ij}$表示从状态$i$出发迟早将转移状态$j$的概率。如果$i \ne j$，当且仅当从$i$到$j$可达时$f_{ij}$为正。$f_{ii}$表示从状态$i$出发迟早会返回该状态的概率。<strong>如果$f_{ii}=1$,则称状态$i$是常返的，否则是非常返的。</strong></p><p><strong>推论</strong></p><ul><li><p>如果$i$是常返的，且$i \leftrightarrow j$，则j是常返的。</p></li><li><p>如果$i\leftrightarrow j$，且j是常返的，则$f_{ij}=1$。</p></li></ul><h3 id="平稳分布与极限分布">平稳分布与极限分布</h3><p>对于式子<br>$$<br>\pi_t=\pi_{t-1}\mathbf{P}=\pi_{t-1}\mathbf{P}\mathbf{P}=\cdots=\pi_0\mathbf{P}^t<br>$$<br>可以发现一个有趣的性质，对于任意的初始状态分布，随着状态转移的进行，最后系统状态的概率分布趋向于一个稳定的值。<br><strong>平稳分布</strong>：假设状态空间的大小为m，向量$\pi$为状态的概率分布。对状态转移矩阵$\mathbf{P}$的马尔可夫链，如果存在一个概率分布$\pi$满足<br>$$<br>\pi \mathbf{P} = \pi<br>$$<br>则称此分布$\pi$为平稳分布。其意义为如果当前时刻的状态如果服从此分布，转移到下一时刻之后还服从此分布，因此称为“平稳”。</p><p>平稳分布即为状态转移矩阵的转置矩阵$\mathbf{P}^T$归一化的特征向量，且特征值为1。<br>（其实就是为了符合特征向量左乘的定义）<br>$$<br>(\pi \mathbf{P})^T = \mathbf{P}^T\pi^T = \pi^T<br>$$</p><p><strong>那么，给定一个状态转移矩阵$\mathbf{P}$，就可以通过求解特征方程来得到对应的平稳分布</strong></p><p>⚠️注意：并非所有的马尔可夫链都存在平稳分布且唯一。</p><h2 id="马尔可夫性质的应用">马尔可夫性质的应用</h2><h3 id="细致平稳条件">细致平稳条件</h3><p>某些应用需要在给定状态概率分布$\pi$的条件下构造出一个马尔可夫链，即构造出一个状态转移矩阵$\mathbf{P}$，使其平稳分布是$\pi$。<strong>细致平稳条件</strong>就是解决此问题的一种办法。<br>$$\begin{equation}<br>\pi_{i}p_{ij} = \pi_j p_{ji}<br>\end{equation}<br>$$</p><p>即对于$\forall i,j$,处于状态$i$的概率乘以从状态$i$转移到状态$j$的概率等于处于状态$j$的概率乘以从状态$j$转移到状态$i$到概率，则$\pi$为马尔可夫链的平稳分布。</p><p>式子(2)称为<strong>细致平稳条件</strong>。</p><p>！注意， $\mathbf{P}$和$\pi$满足细致平衡条件是$\pi$为$\mathbf{P}$的平稳分布的充分条件而非必要条件。</p><pre><code class="hljs">直观上来说，平稳分布意味着对于任意一个状态，从所有状态转入到该状态的概率值与从状态的概率值相等（即从该状态转出去的概率值）。而细致平衡条件显然是一个更严格的要求，要求对任意的两个状态i与j，从i转入到j到概率和从j转入到i的概率相等。</code></pre><h3 id="隐式马尔可夫模型">隐式马尔可夫模型</h3><p>在一些实际应用中并不能直接观察得到系统的状态值，状态的值是隐含的，只能得到一组称为观测的值。隐式马尔可夫模型就是描述了观测变量与状态变量之间的概率关系。</p><p>定义观测序列：<br>$$<br>\mathbf{x}={x_1,\cdots,x_T}<br>$$<br>它是能够直接观察或者计算得到的值，是一个随机变量序列。任何一时刻的观测值都来自有限的观测集<br>$$<br>V = {v_1,\cdots,v_m}<br>$$<br>定义状态序列<br>$$<br>\mathbf{z}={z_1,\cdots,z_T}<br>$$<br>状态序列也是一个随机变量序列。任意时刻的状态值也来自有限的状态集<br>$$<br>S={s_1,\cdots,s_n}<br>$$</p><p>状态序列是一个马尔可夫链，其状态转移矩阵为$\mathbf{A}$。状态随着时间演化，每个时刻的状态值决定了观测值。</p><p>例子：</p><pre><code class="hljs">    假如要识别一个视频里的人的各种动作，那么状态即为要识别的动作，例如站立、坐下和行走等，在进行识别之前无法得知其值。观测是能够直接得到的值，如人体身上各个关键点点坐标，隐式马尔可夫模型通过观测值来推断状态值，从而识别出动作。</code></pre><p><img src="/img/pics/markov/hmm.png" alt="hmm"></p><p>除了状态转移矩阵外，隐式马尔可夫模型还有观测矩阵$\mathbf{B}$，其元素为：<br>$$<br>b_{ij}=p(x_t=v_j|z_t=s_i)<br>$$<br>该值表示t时刻状态值为$s_i$时观测值为$v_j$的概率。观测矩阵的第i行是状态为$s_i$时观测值为各个值的概率分布。那么，假设初始状态分布的概率分布为$\pi$，隐马尔可夫模型可以表示为五元组：<br>$$<br>{S,V,\pi,\mathbf{A},\mathbf{B}}<br>$$<br><strong>实际应用中，一般假设状态转移矩阵$\mathbf{A}$和观测矩阵$\mathbf{B}$在任何时刻都是相同的，即与时间无关，马尔可夫是时齐的，从而简化问题的计算难度</strong></p><p>作为一个例子：</p><pre><code class="hljs">假设我们无法得知天气的情况，但能得知一个人在各种天气下的活动情况，&#123;睡觉、跑步、逛街&#125;，那么天气在这个问题中就是状态值，而活动就是观测值。</code></pre><p>在隐马尔可夫模型中，状态和观测是根据实际问题人工设定的；状态转移矩阵和观测矩阵通过样本学习得到。在给定观测序列$\mathbf{x}$的条件下，可以通过计算出状态序列$\mathbf{z}$出现的概率即条件概率$p(\mathbf{z}|\mathbf{x})$。</p><p>观测序列的产生过程为：系统在1时刻处于状态$z_1$，在该状态下得到观测值为$x_1$。接下来从$z_1$转移到$z_2$，并在此状态下得到观测值$x_2$。以此类推，得到整个观测序列。由于每一时刻的观测值只依赖于本时刻的状态值，因此当出现状态序列$\mathbf{z}$的时候观测序列为$\mathbf{x}$的概率为：<br>$$<br>\begin{align}<br>p(\mathbf{z},\mathbf{x}) &amp;= p(\mathbf{z})p(\mathbf{z}|\mathbf{x}) \<br>&amp;= p(z_{T}|z_{T-1})p(z_{T-1}|z_{T-2})\cdots p(z_{1}|z_{0}) \<br>&amp;\quad \times p(x_{T}|z_{T})p(x_{T-1}|z_{T-1})\cdots p(x_{1}|z_{1})\<br>&amp;= (\prod_{t=1}^{T} a_{z_{t-1}z_t}) \times \prod_{t=1}^{T} b_{z_t x_t} \<br>\end{align}<br>$$<br>其中，约定$p(z_1|z_0)=p(z_1)$为状态的初始概率。</p>]]></content>
    
    
    
    <tags>
      
      <tag>概率论与数理统计，数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计学习基础</title>
    <link href="/2025/10/03/maximum-entropy/"/>
    <url>/2025/10/03/maximum-entropy/</url>
    
    <content type="html"><![CDATA[<h1>统计学习基础</h1><h2 id="熵">熵</h2><h3 id="熵的定义">熵的定义</h3><p>什么是熵呢？熵是在1948年由克劳德·艾尔伍德·香农从热力学中引入到信息论中的概念。信息论中，熵可以理解为<strong>不确定性的度量</strong>。事件的概率分布和每个事件的信息量构成了一个随机变量，这个随机变量的均值（即期望）就是这个分布产生的信息量的平均值（即熵）。</p><p>熵的计算公式如下：</p><p>$$<br>H(P)=-\sum P(x)log_{b}P(x)<br>$$</p><p>在这里b是对数所使用的底，通常是2，自然常数e，或是10。</p><p>熵的单位通常为比特，采用概率分布的对数作为信息的量度的原因是其可加性。一般地，我们需要用log2(n)位来表示一个可以取n个值的变量。例如，如果有一枚理想的硬币，其出现正面和反面的机会相等，那么我们使用一枚正常硬币进行若干次抛掷，这个事件的熵是一比特，因为结果不外乎两个——正面或者反面，可以表示为0, 1编码，而且两个结果彼此之间相互独立。若进行n次独立实验，则熵为n，因为可以用长度为n的比特流表示。</p><p>这里举个例子：<br>假设一个随机变量X，取三种可能值$x_1,x_2,x_3$,概率分别为$\frac{1}{2},\frac{1}{4},\frac{1}{4}$,那么编码的平均比特长度为：<br>$\frac{1}{2}\times 1+\frac{1}{4}\times 2+\frac{1}{4}\times 2 = \frac{2}{3}$</p><p>所以<strong>熵实际是对随机变量的比特量和发生概率相乘再总和的数学期望。</strong></p><h3 id="熵的推广">熵的推广</h3><h4 id="联合熵-joint-entropy">联合熵(joint entropy)</h4><p>如果 $X, Y$ 是一对离散型随机变量 $X, Y ~ p(x, y)，X, Y$ 的联合熵 $H(X, Y)$ 为：</p><p>$$H(X,Y) = \sum_{x \in X}\sum_{y \in Y} p(x,y)log_{2}p(x,y)$$<br>联合熵描述的就是一对随机变量平均所需要的信息量，还可以推广到多个随机变量的情况。</p><h4 id="条件熵-conditional-entropy">条件熵(conditional entropy)</h4><p>给定随机变量 X 的情况下，随机变量 Y 的条件熵定义为：<br>$$\begin{align*}<br>H(X|Y) &amp;= \sum_{x \in X}p(x)H(Y|X=x)\<br>&amp;= \sum_{x \in X}p(x)[- \sum_{y \in Y}p(y|x)log_{2}p(y|x)]\<br>&amp;= \sum_{x \in X}\sum_{y \in Y} p(x,y)log_{2}p(y|x)<br>\end{align*}    $$</p><p>该式可进一步化简为：<br>$$H(X)+H(Y|X)$$</p><h3 id="相对熵-relative-entropy">相对熵(relative entropy)</h3><p>(或称 Kullback-Leibler divergence, K-L 距离，或K-L散度)<br>它衡量的是相同事件空间里的两个概率分布的差异情况。并不是一种距离度量方式，其物理意义是：在相同事件空间里，概率分布P(x)对应的每个事件，若用概率分布 Q(x)编码时，平均每个基本事件（符号）编码长度增加了多少比特。我们用D（P||Q）表示KL距离，计算公式如下：<br>$$D(P||Q) = \sum_{x \in X}P(x)log\frac{P(x)}{Q(x)}$$</p><p>进一步约定<br>$$ 0 log (0/Q) = 0, P log P(/0) = \infty$$</p><p>根据公式，我们可以得到以下结论：</p><ul><li>当P(x)=Q(x)时，D(P||Q)=0,即其相对熵为零。</li><li>当P(x)和Q(x)相似度越高时，KL距离越小</li><li>D(P||Q)非负（非负性）</li><li>不满足对称性，即D(P||Q)≠D(Q||P)</li></ul><p>KL距离主要是衡量两个概率分布的差异。可以理解为利用概率分布Q 拟合概率分布P 时的能量损耗，也就是说拟合以后丢失了多少的信息。<br>在生成式模型中，这个指标会很常用到。</p><h3 id="交叉熵">交叉熵</h3><p>如果一个随机变量X ~ p(x)，理论模型q(x)为用于近似p(x)的概率分布，那么，统计分布p和模型q之间的交叉熵定义为：<br>$$\begin{align*}<br>H(X,q) &amp;= H(X) + D(p||q)\<br>&amp;= \sum_{x \in X}p(x)log p(x) + \sum_{x \in X}p(x)log \frac{p(x)}{q(x)}\<br>&amp;= - \sum_{x \in X} p(x)log q(x)<br>\end{align*}    $$</p><p>交叉熵衡量的也是两个模型分布之间的差异。因为熵是理论上的平均最小编码长度，所以交叉熵只可能大于等于熵。换句话说，如果我们的估计是完美的，即$Q=P$，那么有$H(P,Q) = H(P)$，否则，$H(P,Q) &gt; H(P)$。</p><h3 id="相对熵与交叉熵的区别">相对熵与交叉熵的区别</h3><p>在机器学习中经常用p(x)表示真实数据的概率分布，由于真实数据的概率分布往往无法获得, 所以一般通过大量的训练数据来近似。假设我们通过某个模型得到了训练数据的概率分布q(x), 由于真实数据的概率分布p(x)往往是不变的，因此<strong>最小化交叉熵H(p, q)等效于最小化相对熵D(p||q)</strong>。<br>习惯上机器学习算法中通常采用交叉熵计算损失函数。例如, 在某机器学习任务中定义损失函数为交叉熵: $Loss=H(p, q)$，假设我们训练到得到一个非常好的模型，即 $p(x)\approx q(x)$，此时Loss不会降低为0, 而是一个很小的值, 如Loss=2, 它表示真实数据自身的熵为 $H(p)=2$。如果选择相对熵作为损失函数, 即$Loss=D(p||q)$, 同样假设我们训练得到一个非常好的模型，即 $p(x)\approx q(x)$，此时，Loss= 0，意味着两个概率分布几乎一样。实际上，上述两种方法所得到的Loss仅仅是数值上的区别，训练得到的模型是完全一样的，即两个概念的作用一样。</p><h3 id="最大熵原理">最大熵原理</h3><p>最大熵原理的表述是：<strong>学习概率模型时，在所有可能的概率模型中，熵最大的模型是最好的模型</strong>。</p><p>最大熵原理是在1957 年由E.T.Jaynes 提出的，在只掌握关于未知分布的部分知识时，应该选取符合这些知识但熵值最大的概率分布。因为在这种情况下，符合已知知识的概率分布可能不止一个。熵最大的时候，说明随机变量最不确定，也就是随机变量最随机，对其行为做准确预测最困难。那么最大熵原理的实质就是，<strong>在已知部分知识的前提下，关于未知分布最合理的推断就是符合已知知识最不确定或最随机的推断，这是我们可以作出的不偏不倚的选择，任何其它的选择都意味着我们增加了其它的约束和假设</strong>，这些约束和假设根据我们掌握的信息无法作出。</p><p>因此，最大熵原理就是表述为在满足约束条件的模型集合中选择熵最大的那个模型。</p><h2 id="最大熵模型">最大熵模型</h2><p>假设分类模型是一个条件概率分布$P（Y|X）$, $X\in \chi \subseteq R^{n}$为输入,$Y\in\gamma$为输出，$\chi 和 \gamma$分别为输入和输出的集合。该模型表示的是对于给定的输入$X$，以条件概率$P(Y|X)$输出$Y$。</p><p>如果现有一个训练数据集:<br>$$<br>T={(x_{1},y_{1}), (x_{2},y_{2}),(x_{3},y_{3}),…,(x_N,y_N))}$$</p><p>$x_i$ 表示输入条件，$y_i$ 表示预测值。训练集中每一种情况的概率$\tilde{p}(x,y)$可以通过简单的统计计算得到：<br>$$\tilde{p}(x,y)=样本中含有(x,y)的数量/N$$<br>对于训练集T中的所有样本可通过特征函数(feature function)描述 $x\in X$ 和 $y \in Y$ 之间基于某种条件的关系：</p><p>$$<br>f(x,y) =<br>\begin{cases}<br>1 &amp; \text{x,y之间满足某种条件}  \<br>0 &amp; \text{否则}<br>\end{cases}<br>$$</p><p>$f(·)$实际上是克罗内克(Kronecker )函数。<br>那么接下来，那么，f(x, y)在训练集上关于经验分布$\tilde{p}(x,y)$的期望值可通过下面的式子计算出来：<br>$$E_{\tilde{p}}(f) = \sum_{x ,y} \tilde{p}(x,y)f(x,y) $$<br>对应的理论值则为：<br>$$E_{p}(f) = \sum_{x ,y} p(x,y)f(x,y) $$<br>由于 $p(x, y) = p(x)p(y|x)$，而且所建立的理论模型应该符合训练集中的概率分布（近似相等）,因此，理论期望值计算公式式可以写为:<br>$$E_{p}(f) = \sum_{x ,y} \tilde{p}(x)p(y|x)f(x,y) $$<br>其约束即为：<br>$$E_{\tilde{p}}(f) = E_{p}(f)$$</p><p>假设训练集中有$n \in N$ 个特征函数 $f_j(x, y)$，它们在建模过程中<br>都对输出结果有影响，也就是说有n个约束条件，而理论上能够满足这些约束的模型有很多，它们构成一个集合：<br>$$P = {p|E_p(f_j)=E_{\tilde{p}}(f_j),j\in {1,2,…,n}} $$<br>在所有满足约束的模型中，使条件熵最大的模型就是最大熵模型，也就是我们要寻找的是最合理的模型。</p><p>最大熵模型的学习等价于求解条件约束的优化问题：<br>$$\begin{align*}<br>p^<em>(y|X) &amp;= \arg\max_{p\in P}H(p)\<br>&amp;= \arg\max_{p\in P}{ -\sum_{x,y}\tilde{p}(x)p(y|x)\log p(y|x)}\<br>\text{s.t} \<br>\quad E_p(f_i) &amp;= E_{\tilde{p}}(f_j),j=1,2,3…,n\<br>\sum_{y}p(y|x)&amp;=1<br>\end{align</em>}    $$</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学，信息论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rag</title>
    <link href="/2025/10/03/rag/"/>
    <url>/2025/10/03/rag/</url>
    
    <content type="html"><![CDATA[<h1>RAG概述——原理和实现</h1><p>检索-增强生成(Retrieval-Augmented Generation，RAG)是大语言模型中的一种常用的手段，它通过纳入外部知识来增强llm的性能，可以有效避免其出现幻觉并提高答案的准确度。<br><img src="/img/pics/rag/pics/rag/rag.png" alt="rag"></p><h2 id="Problems-of-llm">Problems of llm</h2><p>大语言模型(LLMs)在自然语言处理尤其是生成上取得了巨大的成就，但它们仍然面临着很大的局限性，特别是在特定领域或知识密集型任务中。在处理超出其训练数据或需要当前信息的查询时，会产生 “幻觉”。</p><pre><code class="hljs">所谓幻觉也就是：大语言模型会给出一些看起来正确但却与事实完全不相符的答案，一个典型的例子就是一本正经地解释“林黛玉倒拔垂杨柳”。这是因为llms事先并不知道水浒传和红楼梦的故事，倘若有一种方法能够将这样的外部知识告诉给模型，模型就可以正确地进行回复。</code></pre><p>RAG就是通过语义相似性计算从外部知识库中检索相关文档块，从而增强了 LLM。通过引用外部知识，RAG 可有效减少生成与事实不符内容的问题。</p><h2 id="How-does-RAG-work">How does RAG work?</h2><p>随着对RAG技术的深入研究，一共出现了三种RAG范式： Naive RAG, Advanced RAG, and Modular RAG.<br><img src="/img/pics/rag/pics/rag/kinds_of_rag.png" alt="kinds of rag"></p><h3 id="naive-rag">naive rag</h3><h4 id="indroduce">indroduce</h4><p>朴素RAG的基本流程是</p><ul><li><p>索引：对于外部数据，首先要进行清理和对不同格式的提取，然后将其转换为<strong>统一的纯文本格式</strong>。为了适应语言模型的<strong>上下文限制</strong>，文本被分割成更小的、易于消化的块。然后，使用嵌入模型将语块编码为<strong>矢量表示</strong>，并存储到矢量数据库中。这一步骤对于在随后的检索阶段进行高效的相似性搜索至关重要。</p></li><li><p>检索：收到用户查询后，RAG 系统会使用索引编制阶段使用的相同编码模型，将查询转换为矢量表示。然后，系统会计算查询向量与索引语料库中的语块向量之间的相似度得分。系统会优先检索与查询相似度最高的 K 个语块。将检索到的数据与用户查询一起作为输入传递给语言模型。</p></li><li><p>生成：提出的查询和选定的文档被合成为一个连贯的提示（一般会有各类模板），而大型语言模型的任务就是对此作出回应。该模型的回答方法可根据任务的具体标准而有所不同，使其既能利用固有的参数知识，也能根据所提供文档中包含的信息进行回答。在持续对话的情况下，任何现有的对话历史记录都可以整合到提示中，从而使模型能够有效地参与多轮对话互动。</p></li></ul><p>这是一种最早也最基本的RAG技术，简单来说就是，它遵循的传统流程是将文档索引到矢量数据库中，根据与用户查询的相似度检索最相关的语块，然后将查询和检索到的语块一起输入语言模型以生成最终答案。</p><h4 id="drawbacks">drawbacks</h4><p>主要是三个问题：</p><ol><li>检索阶段往往在精确度和召回率方面存在困难，导致选择错位或不相关的信息块，以及丢失关键信息。</li><li>在生成回复时，模型可能会面临幻觉问题，即生成的内容与检索到的上下文不符。这一阶段还可能出现输出内容不相关、有误或有偏差的情况，从而影响回复的质量和可靠性。</li><li>将检索到的信息与不同的任务进行整合有时会导致输出结果脱节或不连贯。当从多个来源检索到类似信息时，这一过程还可能遇到冗余问题，从而导致重复的回复。确定不同段落的意义和相关性，并确保文体和音调的一致性，这些都增加了工作的复杂性。</li></ol><p>可以看到面对复杂的问题，基于原始查询的单一检索可能不足以获取足够的上下文信息。此外，生成模型可能会过度依赖增强信息，导致输出结果只是重复检索到的内容，而没有增加有见地的或综合的信息。</p><h3 id="advanced-rag">advanced rag</h3><p>高级 RAG 为了提高检索质量，它采用了检索前和检索后策略。还通过使用滑动窗口方法、细粒度分割和元数据的整合，改进了索引技术。</p><ul><li><p>预检索过程。这一阶段的主要重点是优化索引结构和原始查询。优化索引的目标是 <em>提高索引内容的质量</em> 。这涉及以下策略：<strong>提高数据粒度、优化索引结构、添加元数据、优化排列和混合检索</strong>。而查询优化的目标是 <em>使用户的原始问题更清晰、更适合检索任务</em>。常见的方法包括<strong>查询重写查询转换、查询扩展等技术</strong>。</p><p>例如：将问题&quot;what’s the French capital?“更换为&quot;What is the capital city of France?”</p></li><li><p>检索后过程。检索到相关上下文后，将其与查询进行有效整合至关重要。检索后流程的主要方法包括重新排序信息块和压缩上下文。对检索到的信息重新排序，将最相关的内容移至提示边缘是一项关键策略。将所有相关文档直接输入 LLM 可能会导致信息过载（即用不相关的内容冲淡对关键细节的关注）。为了减轻这种情况，<strong>检索后的工作主要集中在选择基本信息、强调关键部分以及缩短要处理的上下文</strong>。</p></li></ul><h3 id="modular-rag">modular rag</h3><p>模块化 RAG 架构具有更强的适应性和多功能性,它采用了多种策略来改进其组件，例如为相似性搜索添加搜索模块，以及通过微调完善检索器。</p><ul><li><p>新模块：模块化 RAG 框架引入了额外的专业组件，以增强检索和处理能力。</p><ul><li>搜索模块可<strong>适应特定场景</strong>，使用 LLM 生成的代码和查询语言，在搜索引擎、数据库和知识图谱等各种数据源中进行直接搜索。</li><li>内存模块利用 LLM 的内存引导检索，创建了一个无限制的内存池，通过迭代式<strong>自我增强</strong>，使文本与数据分布更紧密地结合在一起。</li><li>预测模块旨在通过 LLM 直接生成上下文，确保相关性和准确性，从而<strong>减少冗余和噪音</strong>。</li><li>“任务适配器”（Task Adapter）模块可<strong>根据各种下游任务对 RAG 进行量身定制</strong>，自动对zero-shot input进行及时检索，并通过few-shot查询生成创建特定任务检索器。这种综合方法不仅简化了检索流程，还显著提高了检索信息的质量和相关性，以更高的精度和灵活性满足各种任务和查询的需要。</li></ul></li><li><p>新模式：模块化 RAG 允许模块替换或重新配置，以应对特定挑战，因而具有出色的适应性。此外，模块化 RAG 还通过集成新模块或调整现有模块之间的交互流程来扩展这种灵活性，从而增强其在不同任务中的适用性。</p></li></ul><h2 id="comparison-between-ft-and-rag">comparison between ft and rag</h2><ol><li>RAG 可以比作为模型提供量身定做的信息检索教科书，是精确信息检索任务的理想选择。相比之下，FT 就好比学生随着时间的推移不断内化知识，适用于需要复制特定结构、风格或格式的场景。</li><li>RAG 在动态环境中表现出色，可提供实时知识更新并有效利用外部知识源，具有很高的可解释性。不过，它的延迟较高，而且在数据检索方面需要考虑道德问题。另一方面，FT 更为静态，更新时需要重新训练，但可以对模型的行为和风格进行深度定制。它需要大量的计算资源来准备和训练数据集，虽然可以减少幻觉，但在处理不熟悉的数据时可能会面临挑战。</li><li>在 RAG 和 FT 之间做出选择，取决于应用环境中对数据动态、定制和计算能力的具体需求。<strong>RAG 和 FT 并不相互排斥，可以相互补充，在不同层面上增强模型的能力</strong>。</li></ol><h2 id="Pratical">Pratical</h2><p>项目地址：<a href="https://colab.research.google.com/github/mrdbourke/simple-local-rag/blob/main/00-simple-local-rag.ipynb">a simple local rag</a></p><p>这个项目介绍了如何建立 一个RAG 管道，使我们能够与llm聊天，并且llm能够学到pdf文档中的知识。</p><p>通过编写以下代码</p><ol><li>打开 PDF 文档（几乎可以使用任何 PDF 文档）。</li><li>将 PDF 教科书的文本格式化，为嵌入模型做好准备（这一过程称为文本分割/分块）。</li><li>嵌入教科书中的所有文本块，并将其转化为我们可以存储的数字表示。</li><li>建立一个检索系统，使用矢量搜索根据查询找到相关的文本块。</li><li>创建一个包含检索到的文本片段的提示。</li><li>根据教科书中的段落生成查询答案。</li><li>上述步骤可分为两个主要部分：</li><li>文档预处理/嵌入创建（步骤 1-3）。</li><li>搜索和回答（第 4-6 步）。</li></ol><h2 id="参考文献">参考文献</h2><p>【1】<a href="https://www.thecloudgirl.dev/blog/three-paradigms-of-retrieval-augmented-generation-rag-for-llms">Three Paradigms of Retrieval-Augmented Generation (RAG) for LLMs</a></p><p>【2】Retrieval-Augmented Generation for Large Language Models: A Survey <a href="https://arxiv.org/pdf/2312.10997">https://arxiv.org/pdf/2312.10997</a></p><p>【3】<a href="https://colab.research.google.com/github/mrdbourke/simple-local-rag/blob/main/00-simple-local-rag.ipynb">a simple local rag</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>RAG,LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合通信</title>
    <link href="/2025/10/03/collections-communication/"/>
    <url>/2025/10/03/collections-communication/</url>
    
    <content type="html"><![CDATA[<h1>集合通信</h1><h2 id="通信模型">通信模型</h2><p>假定在一个分布式机器学习集群中，存在$p$个计算设备，并由一个网络来连接所有的设备。每个设备有自己的独立内存，并且所有设备间的通信都通过该网络传输。同时，每个设备都有一个编号$i$，其中$i$的范围从1到$p$。 设备之间的点对点（Point-to-Point, P2P）通信由全双工传输(Full-Duplex Transmission)实现。该通信模型的基本行为可以定义如下：</p><ul><li>每次通信有且仅有一个发送者（Sender）和一个接收者（Receiver）。在某个特定时刻，每个设备仅能至多发送或接收一个消息（Message）。每个设备可以同时发送一个消息和接收一个消息。一个网络中可以同时传输多个来自于不同设备的消息。</li><li>传输一个长度为$l$个字节（Byte）的消息会花费$a+b \times l$的时间，其中$a$代表延迟（Latency），即一个字节通过网络从一个设备出发到达另一个设备所需的时间；$b$代表传输延迟（Transmission Delay），即传输一个具有$l$个字节的消息所需的全部时间。前者取决于两个设备间的物理距离（如跨设备、跨机器、跨集群等），后者取决于通信网络的带宽。需要注意的是，这里简化了传输延迟的定义，其并不考虑在真实网络传输中会出现的丢失的消息（Dropped Message）和损坏的消息（Corrupted Message）的情况。</li></ul><p>我们可以定义集合通信算子(即通信的行为)，并且分析算子的通信性能。</p><h3 id="Broadcast">Broadcast</h3><p>一个分布式机器学习系统经常需要将一个设备上的模型参数或者配置文件广播（Broadcast）给其余全部设备。因此，可以把Broadcast算子定义为从编号为$i$的设备发送长度为$l$字节的消息给剩余的个设备。</p><p><img src="/img/pics/collections_communication/broadcast.png" alt="broadcast"></p><p>一种简单实现Broadcast的算法是在设备上实现一个循环，该循环使用$p-1$次Send/Receive操作来将数据传输给相应设备。然而，该算法不能达到并行通信的目的（该算法只有$(a+b\times l)\times (p-1)$的线性时间复杂度）。</p><p>为此，可以利用分治思想对上述简单实现的Broadcast算法进行优化。假设所有的设备可以重新对编号进行排列，使得Broadcast的发送者为编号为1的设备。同时，为了简化计算过程，假设对某个自然数$n$，$p=2^n$。 现在，可以通过从$1$向$p/2$发送一次信息把问题转换为两个大小为的子问题：</p><ol><li>编号为1的设备对编号1到编号$p/2-1$的Broadcast</li><li>以及编号为$p/2$的设备对编号$p/2$到编号$p$的Broadcast。</li></ol><p>接下来就可以通过在这两个子问题上进行递归来完成这个算法，并把临界条件定义为编号为$i$的设备在$[i,i]$这个区间中的Broadcast。此时，由于本身已经拥有该信息，不需要做任何操作便可直接完成Broadcast。这个优化后的算法为$(a+b\times l)\times log p$时间复杂度，因为在算法的每一阶段（编号为$t$），有$2^t$个设备在并行运行Broadcast算子。同时，算法一定会在$log p$步之内结束。</p><h3 id="Reduce">Reduce</h3><p>在分布式机器学习系统中，另一个常见的操作是将不同设备上的计算结果进行聚合（Aggregation）。<br><img src="/img/pics/collections_communication/reduce.png" alt="Reduce"><br>例如，将每个设备计算的本地梯度进行聚合，计算梯度之和（Summation）。这些聚合函数（表达为$f$）往往符合结合律（Associative Law）和交换律（Commutative Law）。这些函数由全部设备共同发起，最终聚合结果存在编号为$i$的设备上。常见聚合函数有加和、乘积、最大值和最小值。集合通信将这些函数表达为Reduce算子。</p><p>一个简易的Reduce的优化实现同样可以用分治思想来实现，即把1到$p/2-1$的Reduce结果存到编号为1的设备中，然后把$p/2$到$p$的Reduce结果存到$p/2$上。最后，可以把$p/2$的结果发送至1，执行$f$，并把最后的结果存至$i$。假设$f$的运行时间复杂度为常数并且其输出信息的长度$l$不改变，Reduce的时间复杂度仍然为$(a+b \times l) \times log p$。</p><h3 id="AllReduce">AllReduce</h3><p>集合通信通过引入AllReduce算子，从而将Reduce函数$f$的结果存至所有设备上。<br><img src="/img/pics/collections_communication/allreduce.png" alt="AllReduce"></p><p>一种简单的AllReduce实现方法是首先调用Reduce算法并将聚合结果存到编号为1的设备上。然后，再调用Broadcast算子将聚合结果广播到所有的设备。这种简单的AllReduce实现的时间复杂度为$(a+b\times l) \times log p$。</p><h3 id="Gather">Gather</h3><p>Gather算子可以将全部设备的数据全部收集（Gather）到编号为$i$的设备上。<br><img src="/img/pics/collections_communication/Gather.png" alt="Gather"><br>在收集函数（Gather Function）符合结合律和交换律的情况下，可以通过将其设为Reduce算子中的$f$来实现Gather算子。但是，在这种情况下，无论是基于链表还是数组的实现，在每一步的Reduce操作中$f$的时间复杂度和输出长度$l$都发生了改变。因此，Gather的时间复杂度是$a \times log p + (p - 1)\times b \times l$。这是因为在算法的每一阶段$t$，传输的信息长度为$2^t \times l$。</p><h3 id="AllGather">AllGather</h3><p>AllGather算子会把收集的结果分发到全部的设备上。<br><img src="/img/pics/collections_communication/allgather.png" alt="allgather"><br>在这里，一个简单的方法是使用Gather和Broadcast算子把聚合结果先存到编号为1的设备中，再将其广播到剩余的设备上。这会产生一个的时间复杂度$a \times log p + (p - 1) \times b \times l (a + p\times b \times l) \times log p$，因为在广播时，如果忽略链表/数组实现所带来的额外空间开销，每次通信的长度为$pl$而不是$l$。简化后，得到了一个 $a \times log p + p\times l \times b \times log p$的时间复杂度。在一个基于超立方体的算法下，可以将其进一步优化到和Gather算子一样的时间复杂度$a \times log p + (p - 1)\times b \times l$。</p><h3 id="Scatter">Scatter</h3><p>Scatter算子可以被视作Gather算子的逆运算：把一个存在于编号为$i$的设备上，长度为$p$（信息长度为$p \times l$）的链式数据结构中的值分散到每个设备上，使得编号为$i$的设备会得到$L[i]$的结果。<br><img src="/img/pics/collections_communication/scatter.png" alt="scatter"><br>可以通过模仿Gather算法设计一个简易的Scatter实现：每一步的运算中，我们把现在的子链继续对半切分，并把前半段和后半段作为子问题进行递归。这时候，在算法的每一阶段$t$，传输的信息长度为$l \times 2^{m-t}$，其中是算法总共运行的步骤，不会超过 （见Broadcast算子的介绍）。最终，Scatter算子的简易实现和Gather算子一样都有$a \times log p + (p-1) \times b \times l$ 的时间复杂度。在机器学习系统中，Scatter算子经常同时被用于链式数据结构和可切分的数据结构，例如张量在一个维度上的$p$等分等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>集合通信，分布式训练</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
